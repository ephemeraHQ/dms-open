"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SealedInvitation = exports.SealedInvitationV1 = exports.SealedInvitationHeaderV1 = exports.SealedInvitationV2 = exports.SealedInvitationHeaderV2 = exports.InvitationV1 = void 0;
const long_1 = __importDefault(require("long"));
const PublicKeyBundle_1 = require("./crypto/PublicKeyBundle");
const proto_1 = require("@xmtp/proto");
const Ciphertext_1 = __importDefault(require("./crypto/Ciphertext"));
const crypto_1 = require("./crypto");
const utils_1 = require("./utils");
const Signature_1 = require("./crypto/Signature");
const { b64Decode } = proto_1.fetcher;
/**
 * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message
 */
class InvitationV1 {
    constructor({ topic, context, aes256GcmHkdfSha256, }) {
        if (!topic || !topic.length) {
            throw new Error('Missing topic');
        }
        if (!aes256GcmHkdfSha256 ||
            !aes256GcmHkdfSha256.keyMaterial ||
            !aes256GcmHkdfSha256.keyMaterial.length) {
            throw new Error('Missing key material');
        }
        this.topic = topic;
        this.context = context;
        this.aes256GcmHkdfSha256 = aes256GcmHkdfSha256;
    }
    static createRandom(context) {
        const topic = (0, utils_1.buildDirectMessageTopicV2)(Buffer.from(crypto_1.utils.getRandomValues(new Uint8Array(32)))
            .toString('base64')
            .replace(/=*$/g, '')
            // Replace slashes with dashes so that the topic is still easily split by /
            // We do not treat this as needing to be valid Base64 anywhere
            .replace('/', '-'));
        const keyMaterial = crypto_1.utils.getRandomValues(new Uint8Array(32));
        return new InvitationV1({
            topic,
            aes256GcmHkdfSha256: { keyMaterial },
            context,
        });
    }
    toBytes() {
        return proto_1.invitation.InvitationV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new InvitationV1(proto_1.invitation.InvitationV1.decode(bytes));
    }
}
exports.InvitationV1 = InvitationV1;
class SealedInvitationHeaderV2 {
    constructor({ peerHeader, selfHeader }) {
        if (peerHeader && selfHeader) {
            throw new Error('SealedInvitationHeaderV2 cannot have both peer and self header');
        }
        const usedHeader = peerHeader || selfHeader;
        if (!usedHeader) {
            throw new Error('SealedInvitationHeaderV2 missing peer or self header');
        }
        this.peerHeader = peerHeader;
        this.selfHeader = selfHeader;
        if (!usedHeader.sendKeyBundle ||
            !usedHeader.inboxKeyBundle ||
            !usedHeader.createdNs) {
            throw new Error('SealedInvitationHeaderV2 missing key bundles or creation time');
        }
        this._sendKeyBundle = new PublicKeyBundle_1.SignedPublicKeyBundleV2(usedHeader.sendKeyBundle);
        this._inboxKeyBundle = new PublicKeyBundle_1.SignedPublicKeyBundleV2(usedHeader.inboxKeyBundle);
        this._createdNs = usedHeader.createdNs;
    }
    static create(sendKeyBundle, inboxKeyBundle, peerAddress, created) {
        let selfHeader, peerHeader;
        if (sendKeyBundle.getLinkedAddress(Signature_1.AccountLinkedRole.SEND_KEY) ===
            inboxKeyBundle.getLinkedAddress(Signature_1.AccountLinkedRole.INBOX_KEY)) {
            selfHeader = {
                sendKeyBundle: sendKeyBundle.getPublicKeyBundle(),
                inboxKeyBundle,
                createdNs: (0, utils_1.dateToNs)(created),
                recipientAddress: peerAddress,
            };
        }
        else {
            peerHeader = {
                sendKeyBundle: sendKeyBundle.getPublicKeyBundle(),
                inboxKeyBundle,
                createdNs: (0, utils_1.dateToNs)(created),
            };
        }
        return new SealedInvitationHeaderV2({
            peerHeader,
            selfHeader,
        });
    }
    get createdNs() {
        return this._createdNs;
    }
    get sendKeyBundle() {
        return this._sendKeyBundle;
    }
    get inboxKeyBundle() {
        return this._inboxKeyBundle;
    }
    getPeerAddress(selfAddress) {
        const senderAddress = this.sendKeyBundle.getLinkedAddress(Signature_1.AccountLinkedRole.SEND_KEY);
        const isSender = senderAddress === selfAddress;
        if (isSender && this.selfHeader) {
            return this.selfHeader.recipientAddress;
        }
        else if (!isSender && this.peerHeader) {
            if (this.inboxKeyBundle.getLinkedAddress(Signature_1.AccountLinkedRole.INBOX_KEY) !==
                selfAddress) {
                throw new Error('Self is not part of invitation');
            }
            return senderAddress;
        }
        else {
            throw new Error('SealedInvitationHeaderV2 has wrong peer or self header');
        }
    }
    toBytes() {
        return proto_1.invitation.SealedInvitationHeaderV2.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationHeaderV2(proto_1.invitation.SealedInvitationHeaderV2.decode(bytes));
    }
}
exports.SealedInvitationHeaderV2 = SealedInvitationHeaderV2;
class SealedInvitationV2 {
    constructor({ headerBytes, ciphertext }) {
        if (!headerBytes || !headerBytes.length) {
            throw new Error('Missing header bytes');
        }
        if (!ciphertext) {
            throw new Error('Missing ciphertext');
        }
        this.headerBytes = headerBytes;
        this.ciphertext = new Ciphertext_1.default(ciphertext);
    }
    /**
     * Accessor method for the full header object
     */
    get header() {
        // Use cached value if already exists
        if (this._header) {
            return this._header;
        }
        this._header = SealedInvitationHeaderV2.fromBytes(this.headerBytes);
        return this._header;
    }
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewerInboxKeyBundle) {
        return __awaiter(this, void 0, void 0, function* () {
            // Use cached value if already exists
            if (this._invitation) {
                return this._invitation;
            }
            const header = this.header;
            if (!viewerInboxKeyBundle.accountLinkedKey.matches(header.inboxKeyBundle.accountLinkedKey)) {
                throw new Error('Inbox key bundle does not match invite');
            }
            // V2 invitations are sent in pairs, one to the inviter and one to the invitee,
            // using the respective inbox key bundle of each recipient. Hence when receiving
            // an invitation, we are always the recipient regardless of who the inviter was.
            const secret = yield viewerInboxKeyBundle.sharedSecret(header.sendKeyBundle, header.inboxKeyBundle.preKey, true /* isRecipient */);
            const decryptedBytes = yield (0, crypto_1.decrypt)(this.ciphertext, secret, this.headerBytes);
            this._invitation = InvitationV1.fromBytes(decryptedBytes);
            return this._invitation;
        });
    }
    toBytes() {
        return proto_1.invitation.SealedInvitationV2.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationV2(proto_1.invitation.SealedInvitationV2.decode(bytes));
    }
}
exports.SealedInvitationV2 = SealedInvitationV2;
/**
 * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1
 */
class SealedInvitationHeaderV1 {
    constructor({ sender, recipient, createdNs, }) {
        if (!sender) {
            throw new Error('Missing sender');
        }
        if (!recipient) {
            throw new Error('Missing recipient');
        }
        this.sender = new PublicKeyBundle_1.SignedPublicKeyBundle(sender);
        this.recipient = new PublicKeyBundle_1.SignedPublicKeyBundle(recipient);
        this.createdNs = createdNs;
    }
    toBytes() {
        return proto_1.invitation.SealedInvitationHeaderV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationHeaderV1(proto_1.invitation.SealedInvitationHeaderV1.decode(bytes));
    }
}
exports.SealedInvitationHeaderV1 = SealedInvitationHeaderV1;
class SealedInvitationV1 {
    constructor({ headerBytes, ciphertext }) {
        if (!headerBytes || !headerBytes.length) {
            throw new Error('Missing header bytes');
        }
        if (!ciphertext) {
            throw new Error('Missing ciphertext');
        }
        this.headerBytes = headerBytes;
        this.ciphertext = new Ciphertext_1.default(ciphertext);
    }
    /**
     * Accessor method for the full header object
     */
    get header() {
        // Use cached value if already exists
        if (this._header) {
            return this._header;
        }
        this._header = SealedInvitationHeaderV1.fromBytes(this.headerBytes);
        return this._header;
    }
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewer) {
        return __awaiter(this, void 0, void 0, function* () {
            // Use cached value if already exists
            if (this._invitation) {
                return this._invitation;
            }
            // The constructors for child classes will validate that this is complete
            const header = this.header;
            let secret;
            if (viewer.identityKey.matches(this.header.sender.identityKey)) {
                secret = yield viewer.sharedSecret(header.recipient, header.sender.preKey, false);
            }
            else {
                secret = yield viewer.sharedSecret(header.sender, header.recipient.preKey, true);
            }
            const decryptedBytes = yield (0, crypto_1.decrypt)(this.ciphertext, secret, this.headerBytes);
            this._invitation = InvitationV1.fromBytes(decryptedBytes);
            return this._invitation;
        });
    }
    toBytes() {
        return proto_1.invitation.SealedInvitationV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationV1(proto_1.invitation.SealedInvitationV1.decode(bytes));
    }
}
exports.SealedInvitationV1 = SealedInvitationV1;
/**
 * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation
 */
class SealedInvitation {
    constructor({ v1, v2 }) {
        if (v2) {
            this.v2 = new SealedInvitationV2(v2);
        }
        else if (v1) {
            this.v1 = new SealedInvitationV1(v1);
        }
        else {
            throw new Error('Missing v1 or v2 invitation');
        }
    }
    toBytes() {
        return proto_1.invitation.SealedInvitation.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitation(proto_1.invitation.SealedInvitation.decode(bytes));
    }
    static fromEnvelope(env) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.message || !env.timestampNs) {
                throw new Error('invalid invitation envelope');
            }
            const sealed = SealedInvitation.fromBytes(b64Decode(env.message));
            const envelopeTime = long_1.default.fromString(env.timestampNs);
            const headerTime = ((_a = sealed.v2) === null || _a === void 0 ? void 0 : _a.header.createdNs) || ((_b = sealed.v1) === null || _b === void 0 ? void 0 : _b.header.createdNs);
            if (!headerTime || !headerTime.equals(envelopeTime)) {
                throw new Error('envelope and header timestamp mistmatch');
            }
            return sealed;
        });
    }
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     */
    static createV1({ sender, recipient, created, invitation, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const headerBytes = new SealedInvitationHeaderV1({
                sender: sender.getPublicKeyBundle(),
                recipient,
                createdNs: (0, utils_1.dateToNs)(created),
            }).toBytes();
            const secret = yield sender.sharedSecret(recipient, sender.getCurrentPreKey().publicKey, false);
            const invitationBytes = invitation.toBytes();
            const ciphertext = yield (0, crypto_1.encrypt)(invitationBytes, secret, headerBytes);
            return new SealedInvitation({
                v1: { headerBytes, ciphertext },
                v2: undefined,
            });
        });
    }
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     *
     * @param sendKeyBundle MUST be a bundle linked to the current viewer
     * @param inboxKeyBundle a bundle either linked to the current viewer, or to the invitee
     * @param peerAddress the address of the invitee to whom the invitation is being sent
     * @param created the time at which the invitation was created
     * @param invitation the invitation to be sent
     */
    static createV2({ sendKeyBundle, inboxKeyBundle, peerAddress, created, invitation, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const headerBytes = SealedInvitationHeaderV2.create(sendKeyBundle, inboxKeyBundle, peerAddress, created).toBytes();
            const secret = yield sendKeyBundle.sharedSecret(inboxKeyBundle, sendKeyBundle.getCurrentPreKey().publicKey, false);
            const invitationBytes = invitation.toBytes();
            const ciphertext = yield (0, crypto_1.encrypt)(invitationBytes, secret, headerBytes);
            return new SealedInvitation({
                v1: undefined,
                v2: { headerBytes, ciphertext },
            });
        });
    }
}
exports.SealedInvitation = SealedInvitation;
//# sourceMappingURL=Invitation.js.map