"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeContent = exports.DecodedMessage = exports.MessageV2 = exports.MessageV1 = void 0;
const Conversation_1 = require("./conversations/Conversation");
const proto_1 = require("@xmtp/proto");
const long_1 = __importDefault(require("long"));
const Ciphertext_1 = __importDefault(require("./crypto/Ciphertext"));
const crypto_1 = require("./crypto");
const utils_1 = require("./crypto/utils");
const encryption_1 = require("./crypto/encryption");
const MessageContent_1 = require("./MessageContent");
const utils_2 = require("./utils");
const Compression_1 = require("./Compression");
const keystore_1 = require("./utils/keystore");
const headerBytesAndCiphertext = (msg) => {
    var _a, _b;
    if ((_a = msg.v1) === null || _a === void 0 ? void 0 : _a.ciphertext) {
        return [msg.v1.headerBytes, new Ciphertext_1.default(msg.v1.ciphertext)];
    }
    if ((_b = msg.v2) === null || _b === void 0 ? void 0 : _b.ciphertext) {
        return [msg.v2.headerBytes, new Ciphertext_1.default(msg.v2.ciphertext)];
    }
    throw new Error('unknown message version');
};
// Message is basic unit of communication on the network.
// Message timestamp is set by the sender.
class MessageBase {
    constructor(id, bytes, obj) {
        ;
        [this.headerBytes, this.ciphertext] = headerBytesAndCiphertext(obj);
        this.id = id;
        this.bytes = bytes;
    }
    toBytes() {
        return this.bytes;
    }
}
// Message header carries the sender and recipient keys used to protect message.
// Message timestamp is set by the sender.
class MessageV1 extends MessageBase {
    constructor(id, bytes, obj, header, senderAddress) {
        super(id, bytes, obj);
        this.conversation = undefined;
        this.senderAddress = senderAddress;
        this.header = header;
    }
    static create(obj, header, bytes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!header.sender) {
                throw new Error('missing message sender');
            }
            const senderAddress = new crypto_1.PublicKeyBundle(header.sender).walletSignatureAddress();
            const id = (0, utils_1.bytesToHex)(yield (0, encryption_1.sha256)(bytes));
            return new MessageV1(id, bytes, obj, header, senderAddress);
        });
    }
    get sent() {
        return new Date(this.header.timestamp.toNumber());
    }
    // wallet address derived from the signature of the message recipient
    get recipientAddress() {
        var _a, _b;
        if (!((_b = (_a = this.header) === null || _a === void 0 ? void 0 : _a.recipient) === null || _b === void 0 ? void 0 : _b.identityKey)) {
            return undefined;
        }
        return new crypto_1.PublicKey(this.header.recipient.identityKey).walletSignatureAddress();
    }
    decrypt(keystore, myPublicKeyBundle) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = (yield keystore.decryptV1((0, keystore_1.buildDecryptV1Request)([this], myPublicKeyBundle))).responses;
            if (!responses.length) {
                throw new Error('No response from Keystore');
            }
            const { decrypted } = (0, keystore_1.getResultOrThrow)(responses[0]);
            return decrypted;
        });
    }
    static fromBytes(bytes) {
        const message = proto_1.message.Message.decode(bytes);
        const [headerBytes] = headerBytesAndCiphertext(message);
        const header = proto_1.message.MessageHeaderV1.decode(headerBytes);
        if (!header) {
            throw new Error('missing message header');
        }
        if (!header.sender) {
            throw new Error('missing message sender');
        }
        if (!header.sender.identityKey) {
            throw new Error('missing message sender identity key');
        }
        if (!header.sender.preKey) {
            throw new Error('missing message sender pre-key');
        }
        if (!header.recipient) {
            throw new Error('missing message recipient');
        }
        if (!header.recipient.identityKey) {
            throw new Error('missing message recipient identity-key');
        }
        if (!header.recipient.preKey) {
            throw new Error('missing message recipient pre-key');
        }
        return MessageV1.create(message, header, bytes);
    }
    static encode(keystore, payload, sender, recipient, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = {
                sender,
                recipient,
                timestamp: long_1.default.fromNumber(timestamp.getTime()),
            };
            const headerBytes = proto_1.message.MessageHeaderV1.encode(header).finish();
            const results = yield keystore.encryptV1({
                requests: [
                    {
                        recipient,
                        headerBytes,
                        payload,
                    },
                ],
            });
            if (!results.responses.length) {
                throw new Error('No response from Keystore');
            }
            const { encrypted: ciphertext } = (0, keystore_1.getResultOrThrow)(results.responses[0]);
            const protoMsg = {
                v1: { headerBytes, ciphertext },
                v2: undefined,
            };
            const bytes = proto_1.message.Message.encode(protoMsg).finish();
            return MessageV1.create(protoMsg, header, bytes);
        });
    }
}
exports.MessageV1 = MessageV1;
class MessageV2 extends MessageBase {
    constructor(id, bytes, obj, header) {
        super(id, bytes, obj);
        this.header = header;
    }
    static create(obj, header, bytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = (0, utils_1.bytesToHex)(yield (0, encryption_1.sha256)(bytes));
            return new MessageV2(id, bytes, obj, header);
        });
    }
    get sent() {
        return (0, utils_2.nsToDate)(this.header.createdNs);
    }
}
exports.MessageV2 = MessageV2;
class DecodedMessage {
    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentBytes, contentType, contentTopic, content, sent, error, }) {
        this.id = id;
        this.messageVersion = messageVersion;
        this.senderAddress = senderAddress;
        this.recipientAddress = recipientAddress;
        this.conversation = conversation;
        this.contentType = contentType;
        this.sent = sent;
        this.error = error;
        this.content = content;
        this.contentTopic = contentTopic;
        this.contentBytes = contentBytes;
    }
    toBytes() {
        var _a;
        return proto_1.message.DecodedMessage.encode(Object.assign(Object.assign({}, this), { conversation: {
                topic: this.conversation.topic,
                context: (_a = this.conversation.context) !== null && _a !== void 0 ? _a : undefined,
                createdNs: (0, utils_2.dateToNs)(this.conversation.createdAt),
                peerAddress: this.conversation.peerAddress,
            }, sentNs: (0, utils_2.dateToNs)(this.sent) })).finish();
    }
    static fromBytes(data, client) {
        return __awaiter(this, void 0, void 0, function* () {
            const protoVal = proto_1.message.DecodedMessage.decode(data);
            const messageVersion = protoVal.messageVersion;
            if (messageVersion !== 'v1' && messageVersion !== 'v2') {
                throw new Error('Invalid message version');
            }
            if (!protoVal.conversation) {
                throw new Error('No conversation reference found');
            }
            const { content, contentType, error } = yield decodeContent(protoVal.contentBytes, client);
            return new DecodedMessage(Object.assign(Object.assign({}, protoVal), { content,
                contentType,
                error,
                messageVersion, sent: (0, utils_2.nsToDate)(protoVal.sentNs), conversation: conversationReferenceToConversation(protoVal.conversation, client, messageVersion) }));
        });
    }
    static fromV1Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentBytes, contentTopic, conversation, error) {
        const { id, senderAddress, recipientAddress, sent } = message;
        if (!senderAddress) {
            throw new Error('Sender address is required');
        }
        return new DecodedMessage({
            id,
            messageVersion: 'v1',
            senderAddress,
            recipientAddress,
            sent,
            content,
            contentBytes,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
    static fromV2Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentTopic, contentBytes, conversation, senderAddress, error) {
        const { id, sent } = message;
        return new DecodedMessage({
            id,
            messageVersion: 'v2',
            senderAddress,
            sent,
            content,
            contentBytes,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
}
exports.DecodedMessage = DecodedMessage;
function decodeContent(contentBytes, client) {
    return __awaiter(this, void 0, void 0, function* () {
        const encodedContent = proto_1.content.EncodedContent.decode(contentBytes);
        if (!encodedContent.type) {
            throw new Error('missing content type');
        }
        let content; // eslint-disable-line @typescript-eslint/no-explicit-any
        let contentType = new MessageContent_1.ContentTypeId(encodedContent.type);
        let error;
        yield (0, Compression_1.decompress)(encodedContent, 1000);
        const codec = client.codecFor(contentType);
        if (codec) {
            content = codec.decode(encodedContent, client);
        }
        else {
            error = new Error('unknown content type ' + contentType);
            if (encodedContent.fallback) {
                content = encodedContent.fallback;
                contentType = MessageContent_1.ContentTypeFallback;
            }
        }
        return { content, contentType, error };
    });
}
exports.decodeContent = decodeContent;
function conversationReferenceToConversation(reference, client, version) {
    if (version === 'v1') {
        return new Conversation_1.ConversationV1(client, reference.peerAddress, (0, utils_2.nsToDate)(reference.createdNs));
    }
    if (version === 'v2') {
        return new Conversation_1.ConversationV2(client, reference.topic, reference.peerAddress, (0, utils_2.nsToDate)(reference.createdNs), reference.context);
    }
    throw new Error(`Unknown conversation version ${version}`);
}
//# sourceMappingURL=Message.js.map