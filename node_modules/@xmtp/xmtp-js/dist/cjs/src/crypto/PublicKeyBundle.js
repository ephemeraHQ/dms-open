"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicKeyBundle = exports.SignedPublicKeyBundle = exports.SignedPublicKeyBundleV2 = void 0;
const proto_1 = require("@xmtp/proto");
const PublicKey_1 = require("./PublicKey");
class SignedPublicKeyBundleV2 {
    constructor(bundle) {
        if (!bundle.accountLinkedKey) {
            throw new Error('SignedPublicKeyBundleV2 missing account linked key');
        }
        if (!bundle.preKey) {
            throw new Error('SignedPublicKeyBundleV2 missing pre-key');
        }
        this.accountLinkedKey = new PublicKey_1.AccountLinkedPublicKey(bundle.accountLinkedKey);
        this.preKey = new PublicKey_1.SignedPublicKey(bundle.preKey);
    }
    getLinkedAddress(role) {
        return this.accountLinkedKey.getLinkedAddress(role);
    }
    equals(other) {
        return (this.accountLinkedKey.equals(other.accountLinkedKey) &&
            this.preKey.equals(other.preKey));
    }
}
exports.SignedPublicKeyBundleV2 = SignedPublicKeyBundleV2;
// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.
// The PreKey must be signed by the IdentityKey.
// The IdentityKey must be signed by the wallet to authenticate it.
class SignedPublicKeyBundle {
    constructor(bundle) {
        if (!bundle.identityKey) {
            throw new Error('missing identity key');
        }
        if (!bundle.preKey) {
            throw new Error('missing pre-key');
        }
        this.identityKey = new PublicKey_1.SignedPublicKey(bundle.identityKey);
        this.preKey = new PublicKey_1.SignedPublicKey(bundle.preKey);
    }
    walletSignatureAddress() {
        return this.identityKey.walletSignatureAddress();
    }
    equals(other) {
        return (this.identityKey.equals(other.identityKey) &&
            this.preKey.equals(other.preKey));
    }
    toBytes() {
        return proto_1.publicKey.SignedPublicKeyBundle.encode(this).finish();
    }
    isFromLegacyBundle() {
        return this.identityKey.isFromLegacyKey() && this.preKey.isFromLegacyKey();
    }
    toLegacyBundle() {
        return new PublicKeyBundle({
            identityKey: this.identityKey.toLegacyKey(),
            preKey: this.preKey.toLegacyKey(),
        });
    }
    static fromBytes(bytes) {
        const decoded = proto_1.publicKey.SignedPublicKeyBundle.decode(bytes);
        return new SignedPublicKeyBundle(decoded);
    }
    static fromLegacyBundle(bundle) {
        return new SignedPublicKeyBundle({
            // Note: I am assuming all PublicKeyBundles passed into this have had their identity keys signed by a wallet
            // Maybe that is not universally true in the future
            identityKey: PublicKey_1.SignedPublicKey.fromLegacyKey(bundle.identityKey, true),
            preKey: PublicKey_1.SignedPublicKey.fromLegacyKey(bundle.preKey),
        });
    }
}
exports.SignedPublicKeyBundle = SignedPublicKeyBundle;
// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.
// The PreKey must be signed by the IdentityKey.
// The IdentityKey can be signed by the wallet to authenticate it.
class PublicKeyBundle {
    constructor(bundle) {
        if (!bundle.identityKey) {
            throw new Error('missing identity key');
        }
        if (!bundle.preKey) {
            throw new Error('missing pre-key');
        }
        this.identityKey = new PublicKey_1.PublicKey(bundle.identityKey);
        this.preKey = new PublicKey_1.PublicKey(bundle.preKey);
    }
    equals(other) {
        return (this.identityKey.equals(other.identityKey) &&
            this.preKey.equals(other.preKey));
    }
    walletSignatureAddress() {
        return this.identityKey.walletSignatureAddress();
    }
    toBytes() {
        return proto_1.publicKey.PublicKeyBundle.encode(this).finish();
    }
    static fromBytes(bytes) {
        const decoded = proto_1.publicKey.PublicKeyBundle.decode(bytes);
        return new PublicKeyBundle(decoded);
    }
}
exports.PublicKeyBundle = PublicKeyBundle;
//# sourceMappingURL=PublicKeyBundle.js.map