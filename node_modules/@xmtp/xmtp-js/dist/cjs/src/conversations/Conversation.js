"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationV2 = exports.ConversationV1 = void 0;
const utils_1 = require("../utils");
const ethers_1 = require("ethers");
const Stream_1 = __importDefault(require("../Stream"));
const Message_1 = require("../Message");
const proto_1 = require("@xmtp/proto");
const crypto_1 = require("../crypto");
const encryption_1 = require("../crypto/encryption");
const Text_1 = require("../codecs/Text");
const keystore_1 = require("../utils/keystore");
/**
 * ConversationV1 allows you to view, stream, and send messages to/from a peer address
 */
class ConversationV1 {
    constructor(client, address, createdAt) {
        this.context = undefined;
        this.peerAddress = ethers_1.utils.getAddress(address);
        this.client = client;
        this.createdAt = createdAt;
    }
    get clientAddress() {
        return this.client.address;
    }
    get topic() {
        return (0, utils_1.buildDirectMessageTopic)(this.peerAddress, this.client.address);
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const topic = (0, utils_1.buildDirectMessageTopic)(this.peerAddress, this.client.address);
            const messages = yield this.client.listEnvelopes(topic, this.processEnvelope.bind(this), opts);
            return this.decryptBatch(messages, topic, false);
        });
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated(this.topic, 
        // This won't be performant once we start supporting a remote keystore
        // TODO: Either better batch support or we ditch this under-utilized feature
        this.decodeMessage.bind(this), opts);
    }
    // decodeMessage takes an envelope and either returns a `DecodedMessage` or throws if an error occurs
    decodeMessage(env) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.contentTopic) {
                throw new Error('Missing content topic');
            }
            const msg = yield this.processEnvelope(env);
            const decryptResults = yield this.decryptBatch([msg], env.contentTopic, true);
            if (!decryptResults.length) {
                throw new Error('No results');
            }
            return decryptResults[0];
        });
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream_1.default.create(this.client, [this.topic], (env) => __awaiter(this, void 0, void 0, function* () { return this.decodeMessage(env); }));
    }
    processEnvelope({ message, contentTopic, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageBytes = (0, utils_1.b64Decode)(message);
            const decoded = yield Message_1.MessageV1.fromBytes(messageBytes);
            const { senderAddress, recipientAddress } = decoded;
            // Filter for topics
            if (!senderAddress ||
                !recipientAddress ||
                !contentTopic ||
                (0, utils_1.buildDirectMessageTopic)(senderAddress, recipientAddress) !== this.topic) {
                throw new Error('Headers do not match intended recipient');
            }
            return decoded;
        });
    }
    /**
     * Send a message into the conversation.
     */
    send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            let topics;
            let recipient = yield this.client.getUserContact(this.peerAddress);
            if (!recipient) {
                throw new Error(`recipient ${this.peerAddress} is not registered`);
            }
            if (!(recipient instanceof crypto_1.PublicKeyBundle)) {
                recipient = recipient.toLegacyBundle();
            }
            if (!this.client.contacts.has(this.peerAddress)) {
                topics = [
                    (0, utils_1.buildUserIntroTopic)(this.peerAddress),
                    (0, utils_1.buildUserIntroTopic)(this.client.address),
                    this.topic,
                ];
                this.client.contacts.add(this.peerAddress);
            }
            else {
                topics = [this.topic];
            }
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            const payload = yield this.client.encodeContent(content, options);
            const msg = yield this.createMessage(payload, recipient, options === null || options === void 0 ? void 0 : options.timestamp);
            yield this.client.publishEnvelopes(topics.map((topic) => ({
                contentTopic: topic,
                message: msg.toBytes(),
                timestamp: msg.sent,
            })));
            return Message_1.DecodedMessage.fromV1Message(msg, content, contentType, payload, topics[0], // Just use the first topic for the returned value
            this);
        });
    }
    decryptBatch(messages, topic, throwOnError = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = (yield this.client.keystore.decryptV1((0, keystore_1.buildDecryptV1Request)(messages, this.client.publicKeyBundle))).responses;
            const out = [];
            for (let i = 0; i < responses.length; i++) {
                const result = responses[i];
                const message = messages[i];
                try {
                    const { decrypted } = (0, keystore_1.getResultOrThrow)(result);
                    out.push(yield this.buildDecodedMessage(message, decrypted, topic));
                }
                catch (e) {
                    if (throwOnError) {
                        throw e;
                    }
                    console.warn('Error decoding content', e);
                }
            }
            return out;
        });
    }
    buildDecodedMessage(message, decrypted, topic) {
        return __awaiter(this, void 0, void 0, function* () {
            const { content, contentType, error } = yield (0, Message_1.decodeContent)(decrypted, this.client);
            return Message_1.DecodedMessage.fromV1Message(message, content, contentType, decrypted, topic, this, error);
        });
    }
    createMessage(
    // Payload is expected to be the output of `client.encodeContent`
    payload, recipient, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            timestamp = timestamp || new Date();
            return Message_1.MessageV1.encode(this.client.keystore, payload, this.client.publicKeyBundle, recipient, timestamp);
        });
    }
}
exports.ConversationV1 = ConversationV1;
/**
 * ConversationV2
 */
class ConversationV2 {
    constructor(client, topic, peerAddress, createdAt, context) {
        this.topic = topic;
        this.createdAt = createdAt;
        this.context = context;
        this.client = client;
        this.peerAddress = peerAddress;
    }
    get clientAddress() {
        return this.client.address;
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = yield this.client.listEnvelopes(this.topic, this.processEnvelope.bind(this), opts);
            return this.decryptBatch(messages, false);
        });
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated(this.topic, this.decodeMessage.bind(this), opts);
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream_1.default.create(this.client, [this.topic], this.decodeMessage.bind(this));
    }
    /**
     * Send a message into the conversation
     */
    send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = yield this.client.encodeContent(content, options);
            const msg = yield this.createMessage(payload, options === null || options === void 0 ? void 0 : options.timestamp);
            yield this.client.publishEnvelopes([
                {
                    contentTopic: this.topic,
                    message: msg.toBytes(),
                    timestamp: msg.sent,
                },
            ]);
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            return Message_1.DecodedMessage.fromV2Message(msg, content, contentType, this.topic, payload, this, this.client.address);
        });
    }
    createMessage(
    // Payload is expected to have already gone through `client.encodeContent`
    payload, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = {
                topic: this.topic,
                createdNs: (0, utils_1.dateToNs)(timestamp || new Date()),
            };
            const headerBytes = proto_1.message.MessageHeaderV2.encode(header).finish();
            const digest = yield (0, encryption_1.sha256)((0, utils_1.concat)(headerBytes, payload));
            const signed = {
                payload,
                sender: this.client.signedPublicKeyBundle,
                signature: yield this.client.keystore.signDigest({
                    digest,
                    prekeyIndex: 0,
                    identityKey: undefined,
                }),
            };
            const signedBytes = proto_1.content.SignedContent.encode(signed).finish();
            const ciphertext = yield this.encryptMessage(signedBytes, headerBytes);
            const protoMsg = {
                v1: undefined,
                v2: { headerBytes, ciphertext },
            };
            const bytes = proto_1.message.Message.encode(protoMsg).finish();
            return Message_1.MessageV2.create(protoMsg, header, bytes);
        });
    }
    decryptBatch(messages, throwOnError = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = (yield this.client.keystore.decryptV2(this.buildDecryptRequest(messages))).responses;
            const out = [];
            for (let i = 0; i < responses.length; i++) {
                const result = responses[i];
                const message = messages[i];
                try {
                    const { decrypted } = (0, keystore_1.getResultOrThrow)(result);
                    out.push(yield this.buildDecodedMessage(message, decrypted));
                }
                catch (e) {
                    if (throwOnError) {
                        throw e;
                    }
                    console.warn('Error decoding content', e);
                }
            }
            return out;
        });
    }
    buildDecryptRequest(messages) {
        return {
            requests: messages.map((m) => {
                return {
                    payload: m.ciphertext,
                    headerBytes: m.headerBytes,
                    contentTopic: this.topic,
                };
            }),
        };
    }
    encryptMessage(payload, headerBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const { responses } = yield this.client.keystore.encryptV2({
                requests: [
                    {
                        payload,
                        headerBytes,
                        contentTopic: this.topic,
                    },
                ],
            });
            if (responses.length !== 1) {
                throw new Error('Invalid response length');
            }
            const { encrypted } = (0, keystore_1.getResultOrThrow)(responses[0]);
            return encrypted;
        });
    }
    buildDecodedMessage(msg, decrypted) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // Decode the decrypted bytes into SignedContent
            const signed = proto_1.content.SignedContent.decode(decrypted);
            if (!((_a = signed.sender) === null || _a === void 0 ? void 0 : _a.identityKey) ||
                !((_b = signed.sender) === null || _b === void 0 ? void 0 : _b.preKey) ||
                !signed.signature) {
                throw new Error('incomplete signed content');
            }
            yield validatePrekeys(signed);
            // Verify the signature
            const digest = yield (0, encryption_1.sha256)((0, utils_1.concat)(msg.headerBytes, signed.payload));
            if (!new crypto_1.SignedPublicKey((_c = signed.sender) === null || _c === void 0 ? void 0 : _c.preKey).verify(new crypto_1.Signature(signed.signature), digest)) {
                throw new Error('invalid signature');
            }
            // Derive the sender address from the valid signature
            const senderAddress = yield new crypto_1.SignedPublicKeyBundle(signed.sender).walletSignatureAddress();
            const { content, contentType, error } = yield (0, Message_1.decodeContent)(signed.payload, this.client);
            return Message_1.DecodedMessage.fromV2Message(msg, content, contentType, this.topic, signed.payload, this, senderAddress, error);
        });
    }
    processEnvelope(env) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.message || !env.contentTopic) {
                throw new Error('empty envelope');
            }
            const messageBytes = (0, utils_1.b64Decode)(env.message.toString());
            const msg = proto_1.message.Message.decode(messageBytes);
            if (!msg.v2) {
                throw new Error('unknown message version');
            }
            const header = proto_1.message.MessageHeaderV2.decode(msg.v2.headerBytes);
            if (header.topic !== this.topic) {
                throw new Error('topic mismatch');
            }
            return Message_1.MessageV2.create(msg, header, messageBytes);
        });
    }
    decodeMessage(env) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.contentTopic) {
                throw new Error('Missing content topic');
            }
            const msg = yield this.processEnvelope(env);
            const decryptResults = yield this.decryptBatch([msg], true);
            if (!decryptResults.length) {
                throw new Error('No results');
            }
            return decryptResults[0];
        });
    }
}
exports.ConversationV2 = ConversationV2;
function validatePrekeys(signed) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        // Check that the pre key is signed by the identity key
        // this is required to chain the prekey-signed message to the identity key
        // and finally to the user's wallet address
        const senderPreKey = (_a = signed.sender) === null || _a === void 0 ? void 0 : _a.preKey;
        if (!senderPreKey || !senderPreKey.signature || !senderPreKey.keyBytes) {
            throw new Error('missing pre-key or pre-key signature');
        }
        const senderIdentityKey = (_b = signed.sender) === null || _b === void 0 ? void 0 : _b.identityKey;
        if (!senderIdentityKey) {
            throw new Error('missing identity key in bundle');
        }
        const isValidPrekey = yield new crypto_1.SignedPublicKey(senderIdentityKey).verifyKey(new crypto_1.SignedPublicKey(senderPreKey));
        if (!isValidPrekey) {
            throw new Error('pre key not signed by identity key');
        }
    });
}
//# sourceMappingURL=Conversation.js.map