"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultKeystoreProviders = exports.defaultOptions = exports.Compression = void 0;
const PrivateKeyBundle_1 = require("./crypto/PrivateKeyBundle");
const crypto_1 = require("./crypto");
const utils_1 = require("./utils");
const ethers_1 = require("ethers");
const conversations_1 = require("./conversations");
const Text_1 = require("./codecs/Text");
const Compression_1 = require("./Compression");
const proto_1 = require("@xmtp/proto");
const ContactBundle_1 = require("./ContactBundle");
const ApiClient_1 = __importStar(require("./ApiClient"));
const authn_1 = require("./authn");
const BackupClient_1 = require("./message-backup/BackupClient");
const BackupClientFactory_1 = require("./message-backup/BackupClientFactory");
const providers_1 = require("./keystore/providers");
const { Compression } = proto_1.content;
exports.Compression = Compression;
const { b64Decode } = proto_1.fetcher;
// eslint-disable @typescript-eslint/explicit-module-boundary-types
// eslint-disable @typescript-eslint/no-explicit-any
// Default maximum allowed content size
const MaxContentSize = 100 * 1024 * 1024; // 100M
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
function defaultOptions(opts) {
    const _defaultOptions = {
        privateKeyOverride: undefined,
        env: 'dev',
        apiUrl: undefined,
        codecs: [new Text_1.TextCodec()],
        maxContentSize: MaxContentSize,
        persistConversations: true,
        skipContactPublishing: false,
        keystoreProviders: defaultKeystoreProviders(),
    };
    if (opts === null || opts === void 0 ? void 0 : opts.codecs) {
        opts.codecs = _defaultOptions.codecs.concat(opts.codecs);
    }
    return Object.assign(Object.assign({}, _defaultOptions), opts);
}
exports.defaultOptions = defaultOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
class Client {
    constructor(publicKeyBundle, apiClient, backupClient, keystore) {
        this.contacts = new Set();
        this.knownPublicKeyBundles = new Map();
        // TODO: Remove keys and legacyKeys
        this.keystore = keystore;
        this.publicKeyBundle = publicKeyBundle;
        this.address = publicKeyBundle.walletSignatureAddress();
        this._conversations = new conversations_1.Conversations(this);
        this._codecs = new Map();
        this._maxContentSize = MaxContentSize;
        this.apiClient = apiClient;
        this._backupClient = backupClient;
    }
    /**
     * @type {Conversations}
     */
    get conversations() {
        return this._conversations;
    }
    get backupType() {
        return this._backupClient.backupType;
    }
    get signedPublicKeyBundle() {
        return crypto_1.SignedPublicKeyBundle.fromLegacyBundle(this.publicKeyBundle);
    }
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = defaultOptions(opts);
            const apiClient = createApiClientFromOptions(options);
            const keystore = yield bootstrapKeystore(options, apiClient, wallet);
            const publicKeyBundle = new crypto_1.PublicKeyBundle(yield keystore.getPublicKeyBundle());
            const address = publicKeyBundle.walletSignatureAddress();
            apiClient.setAuthenticator(new authn_1.KeystoreAuthenticator(keystore));
            const backupClient = yield Client.setupBackupClient(address, options.env);
            const client = new Client(publicKeyBundle, apiClient, backupClient, keystore);
            yield client.init(options);
            return client;
        });
    }
    /**
     * Export the XMTP PrivateKeyBundle from the SDK as a `Uint8Array`.
     *
     * This bundle can then be provided as `privateKeyOverride` in a
     * subsequent call to `Client.create(...)`
     *
     * Be very careful with these keys, as they can be used to
     * impersonate a user on the XMTP network and read the user's
     * messages.
     */
    static getKeys(wallet, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield Client.create(wallet, opts);
            const keys = yield client.keystore.getPrivateKeyBundle();
            return new PrivateKeyBundle_1.PrivateKeyBundleV1(keys).encode();
        });
    }
    static setupBackupClient(walletAddress, env) {
        return __awaiter(this, void 0, void 0, function* () {
            // Hard-code the provider to use for now
            const selectBackupProvider = () => __awaiter(this, void 0, void 0, function* () {
                return Promise.resolve({
                    type: env === 'local' ? BackupClient_1.BackupType.xmtpTopicStore : BackupClient_1.BackupType.none,
                });
            });
            return (0, BackupClientFactory_1.createBackupClient)(walletAddress, selectBackupProvider);
        });
    }
    init(options) {
        return __awaiter(this, void 0, void 0, function* () {
            options.codecs.forEach((codec) => {
                this.registerCodec(codec);
            });
            this._maxContentSize = options.maxContentSize;
            if (!options.skipContactPublishing) {
                yield this.ensureUserContactPublished(options.publishLegacyContact);
            }
        });
    }
    // gracefully shut down the client
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
    ensureUserContactPublished(legacy = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const bundle = yield getUserContactFromNetwork(this.apiClient, this.address);
            if (bundle &&
                bundle instanceof crypto_1.SignedPublicKeyBundle &&
                this.signedPublicKeyBundle.equals(bundle)) {
                return;
            }
            // TEMPORARY: publish V1 contact to make sure there is one in the topic
            // in order to preserve compatibility with pre-v7 clients.
            // Remove when pre-v7 clients are deprecated
            yield this.publishUserContact(true);
            if (!legacy) {
                yield this.publishUserContact(legacy);
            }
        });
    }
    // PRIVATE: publish the key bundle into the contact topic
    // left public for testing purposes
    publishUserContact(legacy = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const bundle = legacy ? this.publicKeyBundle : this.signedPublicKeyBundle;
            yield this.publishEnvelopes([
                {
                    contentTopic: (0, utils_1.buildUserContactTopic)(this.address),
                    message: (0, ContactBundle_1.encodeContactBundle)(bundle),
                },
            ]);
        });
    }
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     *
     * This throws if either the address is invalid or the contact is not published.
     * See also [#canMessage].
     */
    getUserContact(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            peerAddress = ethers_1.utils.getAddress(peerAddress); // EIP55 normalize the address case.
            const existingBundle = this.knownPublicKeyBundles.get(peerAddress);
            if (existingBundle) {
                return existingBundle;
            }
            const newBundle = yield getUserContactFromNetwork(this.apiClient, peerAddress);
            if (newBundle) {
                this.knownPublicKeyBundles.set(peerAddress, newBundle);
            }
            return newBundle;
        });
    }
    /**
     * Identical to getUserContact but for multiple peer addresses
     */
    getUserContacts(peerAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            // EIP55 normalize all peer addresses
            const normalizedAddresses = peerAddresses.map((address) => ethers_1.utils.getAddress(address));
            // The logic here is tricky because we need to do a batch query for any uncached bundles,
            // then interleave back into an ordered array. So we create a map<string, keybundle|undefined>
            // and fill it with cached values, then take any undefined entries and form a BatchQuery from those.
            const addressToBundle = new Map();
            const uncachedAddresses = [];
            for (const address of normalizedAddresses) {
                const existingBundle = this.knownPublicKeyBundles.get(address);
                if (existingBundle) {
                    addressToBundle.set(address, existingBundle);
                }
                else {
                    addressToBundle.set(address, undefined);
                    uncachedAddresses.push(address);
                }
            }
            // Now do a getUserContactsFromNetwork call
            const newBundles = yield getUserContactsFromNetwork(this.apiClient, uncachedAddresses);
            // Now merge the newBundles into the addressToBundle map
            for (let i = 0; i < newBundles.length; i++) {
                const address = uncachedAddresses[i];
                const bundle = newBundles[i];
                addressToBundle.set(address, bundle);
                // If the bundle is not undefined, cache it
                if (bundle) {
                    this.knownPublicKeyBundles.set(address, bundle);
                }
            }
            // Finally return the bundles in the same order as the input addresses
            return normalizedAddresses.map((address) => addressToBundle.get(address));
        });
    }
    /**
     * Used to force getUserContact fetch contact from the network.
     */
    forgetContact(peerAddress) {
        peerAddress = ethers_1.utils.getAddress(peerAddress); // EIP55 normalize the address case.
        this.knownPublicKeyBundles.delete(peerAddress);
    }
    /**
     * Check if @peerAddress can be messaged, specifically
     * it checks that a PublicKeyBundle can be found for the given address
     */
    canMessage(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (Array.isArray(peerAddress)) {
                    const contacts = yield this.getUserContacts(peerAddress);
                    return contacts.map((contact) => !!contact);
                }
                // Else do the single address case
                const keyBundle = yield this.getUserContact(peerAddress);
                return keyBundle !== undefined;
            }
            catch (e) {
                // Instead of throwing, a bad address should just return false.
                return false;
            }
        });
    }
    static canMessage(peerAddress, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const apiUrl = (opts === null || opts === void 0 ? void 0 : opts.apiUrl) || ApiClient_1.ApiUrls[(opts === null || opts === void 0 ? void 0 : opts.env) || 'dev'];
            if (Array.isArray(peerAddress)) {
                const rawPeerAddresses = peerAddress;
                // Try to normalize each of the peer addresses
                const normalizedPeerAddresses = rawPeerAddresses.map((address) => ethers_1.utils.getAddress(address));
                // The getUserContactsFromNetwork will return false instead of throwing
                // on invalid envelopes
                const contacts = yield getUserContactsFromNetwork(new ApiClient_1.default(apiUrl, { appVersion: opts === null || opts === void 0 ? void 0 : opts.appVersion }), normalizedPeerAddresses);
                return contacts.map((contact) => !!contact);
            }
            try {
                peerAddress = ethers_1.utils.getAddress(peerAddress); // EIP55 normalize the address case.
            }
            catch (e) {
                return false;
            }
            const keyBundle = yield getUserContactFromNetwork(new ApiClient_1.default(apiUrl, { appVersion: opts === null || opts === void 0 ? void 0 : opts.appVersion }), peerAddress);
            return keyBundle !== undefined;
        });
    }
    validateEnvelope(env) {
        const bytes = env.message;
        if (!env.contentTopic) {
            throw new Error('Missing content topic');
        }
        if (!bytes || !bytes.length) {
            throw new Error('Cannot publish empty message');
        }
    }
    /**
     * Low level method for publishing envelopes to the XMTP network with
     * no pre-processing or encryption applied.
     *
     * Primarily used internally
     *
     * @param envelopes PublishParams[]
     */
    publishEnvelopes(envelopes) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const env of envelopes) {
                this.validateEnvelope(env);
            }
            try {
                yield this.apiClient.publish(envelopes);
            }
            catch (err) {
                console.log(err);
            }
        });
    }
    /**
     * Register a codec to be automatically used for encoding/decoding
     * messages of the given Content Type
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerCodec(codec) {
        const id = codec.contentType;
        const key = `${id.authorityId}/${id.typeId}`;
        this._codecs.set(key, codec);
    }
    /**
     * Find a matching codec for a given `ContentTypeId` from the
     * client's codec registry
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    codecFor(contentType) {
        const key = `${contentType.authorityId}/${contentType.typeId}`;
        const codec = this._codecs.get(key);
        if (!codec) {
            return undefined;
        }
        if (contentType.versionMajor > codec.contentType.versionMajor) {
            return undefined;
        }
        return codec;
    }
    /**
     * Convert arbitrary content into a serialized `EncodedContent` instance
     * with the given options
     */
    encodeContent(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            const codec = this.codecFor(contentType);
            if (!codec) {
                throw new Error('unknown content type ' + contentType);
            }
            const encoded = codec.encode(content, this);
            if (options === null || options === void 0 ? void 0 : options.contentFallback) {
                encoded.fallback = options.contentFallback;
            }
            if (typeof (options === null || options === void 0 ? void 0 : options.compression) === 'number') {
                encoded.compression = options.compression;
            }
            yield (0, Compression_1.compress)(encoded);
            return proto_1.content.EncodedContent.encode(encoded).finish();
        });
    }
    listInvitations(opts) {
        return this.listEnvelopes((0, utils_1.buildUserInviteTopic)(this.address), (env) => __awaiter(this, void 0, void 0, function* () { return env; }), opts);
    }
    /**
     * List stored messages from the specified topic.
     *
     * A specified mapper function will be applied to each envelope.
     * If the mapper function throws an error during processing, the
     * envelope will be discarded.
     */
    listEnvelopes(topic, mapper, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!opts) {
                opts = {};
            }
            const { startTime, endTime, limit } = opts;
            const envelopes = yield this.apiClient.query({ contentTopic: topic, startTime, endTime }, {
                direction: opts.direction || proto_1.messageApi.SortDirection.SORT_DIRECTION_ASCENDING,
                limit,
            });
            const results = [];
            for (const env of envelopes) {
                if (!env.message)
                    continue;
                try {
                    const res = yield mapper(env);
                    results.push(res);
                }
                catch (e) {
                    console.warn('Error in listEnvelopes mapper', e);
                }
            }
            return results;
        });
    }
    /**
     * List messages on a given set of content topics, yielding one page at a time
     */
    listEnvelopesPaginated(contentTopic, mapper, opts) {
        return (0, utils_1.mapPaginatedStream)(this.apiClient.queryIteratePages({
            contentTopic,
            startTime: opts === null || opts === void 0 ? void 0 : opts.startTime,
            endTime: opts === null || opts === void 0 ? void 0 : opts.endTime,
        }, { direction: opts === null || opts === void 0 ? void 0 : opts.direction, pageSize: (opts === null || opts === void 0 ? void 0 : opts.pageSize) || 100 }), mapper);
    }
}
exports.default = Client;
function createApiClientFromOptions(options) {
    const apiUrl = options.apiUrl || ApiClient_1.ApiUrls[options.env];
    return new ApiClient_1.default(apiUrl, { appVersion: options.appVersion });
}
/**
 * Retrieve a key bundle from given user's contact topic
 */
function getUserContactFromNetwork(apiClient, peerAddress) {
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function* () {
        const stream = apiClient.queryIterator({ contentTopic: (0, utils_1.buildUserContactTopic)(peerAddress) }, { pageSize: 5, direction: ApiClient_1.SortDirection.SORT_DIRECTION_DESCENDING });
        try {
            for (var stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), !stream_1_1.done;) {
                const env = stream_1_1.value;
                if (!env.message)
                    continue;
                const keyBundle = (0, ContactBundle_1.decodeContactBundle)(b64Decode(env.message.toString()));
                const address = yield (keyBundle === null || keyBundle === void 0 ? void 0 : keyBundle.walletSignatureAddress());
                if (address === peerAddress) {
                    return keyBundle;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (stream_1_1 && !stream_1_1.done && (_a = stream_1.return)) yield _a.call(stream_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    });
}
/**
 * Retrieve a list of key bundles given a list of user addresses
 */
function getUserContactsFromNetwork(apiClient, peerAddresses) {
    return __awaiter(this, void 0, void 0, function* () {
        const userContactTopics = peerAddresses.map(utils_1.buildUserContactTopic);
        const topicToEnvelopes = yield apiClient.batchQuery(userContactTopics.map((topic) => ({
            contentTopic: topic,
            pageSize: 5,
            direction: ApiClient_1.SortDirection.SORT_DIRECTION_DESCENDING,
        })));
        // Transform topicToEnvelopes into a list of PublicKeyBundles or undefined
        // by going through each message and attempting to decode
        return Promise.all(peerAddresses.map((address, index) => __awaiter(this, void 0, void 0, function* () {
            const envelopes = topicToEnvelopes[index];
            if (!envelopes) {
                return undefined;
            }
            for (const env of envelopes) {
                if (!env.message)
                    continue;
                try {
                    const keyBundle = (0, ContactBundle_1.decodeContactBundle)(b64Decode(env.message.toString()));
                    const signingAddress = yield (keyBundle === null || keyBundle === void 0 ? void 0 : keyBundle.walletSignatureAddress());
                    if (address === signingAddress) {
                        return keyBundle;
                    }
                    else {
                        console.info('Received contact bundle with incorrect address');
                    }
                }
                catch (e) {
                    console.info('Invalid contact bundle', e);
                }
            }
            return undefined;
        })));
    });
}
/**
 * Get the default list of `KeystoreProviders` used in the SDK
 *
 * Particularly useful if a developer wants to add their own
 * provider to the head of the list while falling back to the
 * default functionality
 */
function defaultKeystoreProviders() {
    return [
        // First check to see if a `privateKeyOverride` is provided and use that
        new providers_1.StaticKeystoreProvider(),
        // Next check to see if a EncryptedPrivateKeyBundle exists on the network for the wallet
        new providers_1.NetworkKeystoreProvider(),
        // If the first two failed with `KeystoreProviderUnavailableError`, then generate a new key and write it to the network
        new providers_1.KeyGeneratorKeystoreProvider(),
    ];
}
exports.defaultKeystoreProviders = defaultKeystoreProviders;
/**
 * Take an array of KeystoreProviders from the options and try them until one succeeds
 */
function bootstrapKeystore(opts, apiClient, wallet) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const provider of opts.keystoreProviders) {
            try {
                return yield provider.newKeystore(opts, apiClient, wallet !== null && wallet !== void 0 ? wallet : undefined);
            }
            catch (err) {
                if (err instanceof providers_1.KeystoreProviderUnavailableError) {
                    continue;
                }
                throw err;
            }
        }
        throw new Error('No keystore providers available');
    });
}
//# sourceMappingURL=Client.js.map