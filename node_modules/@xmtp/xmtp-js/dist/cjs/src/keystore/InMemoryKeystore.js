"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const proto_1 = require("@xmtp/proto");
const PrivateKeyBundle_1 = require("./../crypto/PrivateKeyBundle");
const Invitation_1 = require("./../Invitation");
const encryption_1 = require("./encryption");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const InviteStore_1 = __importDefault(require("./InviteStore"));
const LocalAuthenticator_1 = __importDefault(require("../authn/LocalAuthenticator"));
const Signature_1 = require("../crypto/Signature");
const { ErrorCode } = proto_1.keystore;
class InMemoryKeystore {
    constructor(keys, inviteStore) {
        this.v1Keys = keys;
        this.v2Keys = PrivateKeyBundle_1.PrivateKeyBundleV2.fromLegacyBundle(keys);
        this.inviteStore = inviteStore;
        this.authenticator = new LocalAuthenticator_1.default(keys.identityKey);
    }
    static create(keys, persistence) {
        return __awaiter(this, void 0, void 0, function* () {
            return new InMemoryKeystore(keys, yield InviteStore_1.default.create(persistence));
        });
    }
    decryptV1(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload', 'peerKeys'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'invalid');
                }
                const { payload, peerKeys, headerBytes, isSender } = req;
                const decrypted = yield (0, encryption_1.decryptV1)(this.v1Keys, (0, utils_1.toPublicKeyBundle)(peerKeys), payload, headerBytes, isSender);
                return {
                    decrypted,
                };
            }), proto_1.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);
            return proto_1.keystore.DecryptResponse.fromPartial({
                responses,
            });
        });
    }
    decryptV2(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { payload, headerBytes, contentTopic } = req;
                const topicData = this.inviteStore.lookup(contentTopic);
                if (!topicData) {
                    // This is the wrong error type. Will add to the proto repo later
                    throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
                }
                const decrypted = yield (0, encryption_1.decryptV2)(payload, (0, utils_1.getKeyMaterial)(topicData.invitation), headerBytes);
                return { decrypted };
            }), ErrorCode.ERROR_CODE_UNSPECIFIED);
            return proto_1.keystore.DecryptResponse.fromPartial({
                responses,
            });
        });
    }
    encryptV1(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload', 'recipient'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { recipient, payload, headerBytes } = req;
                return {
                    encrypted: yield (0, encryption_1.encryptV1)(this.v1Keys, (0, utils_1.toPublicKeyBundle)(recipient), payload, headerBytes),
                };
            }), ErrorCode.ERROR_CODE_UNSPECIFIED);
            return proto_1.keystore.EncryptResponse.fromPartial({
                responses,
            });
        });
    }
    createAuthToken({ timestampNs, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.authenticator.createToken(timestampNs ? (0, utils_2.nsToDate)(timestampNs) : undefined);
        });
    }
    encryptV2(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { payload, headerBytes, contentTopic } = req;
                const topicData = this.inviteStore.lookup(contentTopic);
                if (!topicData) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
                }
                return {
                    encrypted: yield (0, encryption_1.encryptV2)(payload, (0, utils_1.getKeyMaterial)(topicData.invitation), headerBytes),
                };
            }), ErrorCode.ERROR_CODE_INVALID_INPUT);
            return proto_1.keystore.EncryptResponse.fromPartial({
                responses,
            });
        });
    }
    saveInvites(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const toAdd = [];
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, ({ payload, timestampNs }) => __awaiter(this, void 0, void 0, function* () {
                const sealed = Invitation_1.SealedInvitation.fromBytes(payload);
                if (sealed.v1) {
                    const headerTime = sealed.v1.header.createdNs;
                    if (!headerTime.equals(timestampNs)) {
                        throw new Error('envelope and header timestamp mismatch');
                    }
                    const isSender = sealed.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle());
                    const invitation = yield sealed.v1.getInvitation(this.v2Keys);
                    const topicData = {
                        invitation,
                        createdNs: sealed.v1.header.createdNs,
                        peerAddress: isSender
                            ? yield sealed.v1.header.recipient.walletSignatureAddress()
                            : yield sealed.v1.header.sender.walletSignatureAddress(),
                    };
                    toAdd.push(topicData);
                    return {
                        conversation: (0, utils_1.topicDataToConversationReference)(topicData),
                    };
                }
                else if (sealed.v2) {
                    const headerTime = sealed.v2.header.createdNs;
                    if (!headerTime.equals(timestampNs)) {
                        throw new Error('envelope and header timestamp mismatch');
                    }
                    const invitation = yield sealed.v2.getInvitation(PrivateKeyBundle_1.PrivateKeyBundleV3.fromLegacyBundle(this.v2Keys, Signature_1.AccountLinkedRole.INBOX_KEY));
                    const selfAddress = yield this.getAccountAddress();
                    const topicData = {
                        invitation,
                        createdNs: sealed.v2.header.createdNs,
                        peerAddress: sealed.v2.header.getPeerAddress(selfAddress),
                    };
                    toAdd.push(topicData);
                    return {
                        conversation: (0, utils_1.topicDataToConversationReference)(topicData),
                    };
                }
            }), ErrorCode.ERROR_CODE_INVALID_INPUT);
            yield this.inviteStore.add(toAdd);
            return proto_1.keystore.SaveInvitesResponse.fromPartial({
                responses,
            });
        });
    }
    createInvite(req) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!(0, utils_1.validateObject)(req, ['recipient'], [])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing recipient');
                }
                const invitation = Invitation_1.InvitationV1.createRandom(req.context);
                const created = (0, utils_2.nsToDate)(req.createdNs);
                const recipient = (0, utils_1.toSignedPublicKeyBundle)(req.recipient);
                const sealed = yield Invitation_1.SealedInvitation.createV1({
                    sender: this.v2Keys,
                    recipient,
                    created,
                    invitation,
                });
                const topicData = {
                    invitation,
                    createdNs: req.createdNs,
                    peerAddress: yield recipient.walletSignatureAddress(),
                };
                yield this.inviteStore.add([topicData]);
                return proto_1.keystore.CreateInviteResponse.fromPartial({
                    conversation: (0, utils_1.topicDataToConversationReference)(topicData),
                    payload: sealed.toBytes(),
                });
            }
            catch (e) {
                throw (0, utils_1.convertError)(e, ErrorCode.ERROR_CODE_INVALID_INPUT);
            }
        });
    }
    signDigest(req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_1.validateObject)(req, ['digest'], [])) {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
            }
            const { digest, identityKey, prekeyIndex } = req;
            let key;
            if (identityKey) {
                key = this.v1Keys.identityKey;
            }
            else if (typeof prekeyIndex !== 'undefined' &&
                Number.isInteger(prekeyIndex)) {
                key = this.v1Keys.preKeys[prekeyIndex];
                if (!key) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no prekey found');
                }
            }
            else {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'must specifify identityKey or prekeyIndex');
            }
            return key.sign(digest);
        });
    }
    getV2Conversations() {
        return __awaiter(this, void 0, void 0, function* () {
            const convos = this.inviteStore.topics.map((invite) => (0, utils_1.topicDataToConversationReference)(invite));
            convos.sort((a, b) => a.createdNs.div(1000000).sub(b.createdNs.div(1000000)).toNumber());
            return convos;
        });
    }
    getPublicKeyBundle() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v1Keys.getPublicKeyBundle();
        });
    }
    getPrivateKeyBundle() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v1Keys;
        });
    }
    getAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.accountAddress) {
                this.accountAddress = yield this.v2Keys
                    .getPublicKeyBundle()
                    .walletSignatureAddress();
            }
            return this.accountAddress;
        });
    }
}
exports.default = InMemoryKeystore;
//# sourceMappingURL=InMemoryKeystore.js.map