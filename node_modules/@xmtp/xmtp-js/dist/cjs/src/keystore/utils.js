"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeSafeTopicMap = exports.isCompleteTopicData = exports.topicDataToConversationReference = exports.getKeyMaterial = exports.validateObject = exports.toSignedPublicKeyBundle = exports.toPublicKeyBundle = exports.mapAndConvertErrors = exports.wrapResult = exports.convertError = void 0;
const proto_1 = require("@xmtp/proto");
const crypto_1 = require("../crypto");
const errors_1 = require("./errors");
const convertError = (e, 
// Default error code to apply to errors that don't have one
errorCode) => {
    if (e instanceof errors_1.KeystoreError) {
        return e;
    }
    return new errors_1.KeystoreError(errorCode, e.message);
};
exports.convertError = convertError;
const wrapResult = (result) => ({ result });
exports.wrapResult = wrapResult;
// Map an array of items to an array of results or errors
// Transform any errors thrown into `KeystoreError`s
const mapAndConvertErrors = (input, mapper, 
// Default error code to apply to errors that don't have one
errorCode) => {
    return Promise.all(input.map((item) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            // Be sure to await mapper result to catch errors
            return (0, exports.wrapResult)(yield mapper(item));
        }
        catch (e) {
            return { error: (0, exports.convertError)(e, errorCode) };
        }
    })));
};
exports.mapAndConvertErrors = mapAndConvertErrors;
// Wrap the bundle in our class if not already wrapped
const toPublicKeyBundle = (bundle) => {
    if (bundle instanceof crypto_1.PublicKeyBundle) {
        return bundle;
    }
    return new crypto_1.PublicKeyBundle(bundle);
};
exports.toPublicKeyBundle = toPublicKeyBundle;
// Wrap the bundle in our class if not already wrapped
const toSignedPublicKeyBundle = (bundle) => {
    if (bundle instanceof crypto_1.SignedPublicKeyBundle) {
        return bundle;
    }
    return new crypto_1.SignedPublicKeyBundle(bundle);
};
exports.toSignedPublicKeyBundle = toSignedPublicKeyBundle;
// Takes object and returns true if none of the `objectFields` are null or undefined and none of the `arrayFields` are empty
const validateObject = (obj, objectFields, arrayFields) => {
    for (const field of objectFields) {
        if (!obj[field]) {
            throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(field)}`);
        }
    }
    for (const field of arrayFields) {
        const val = obj[field];
        // @ts-expect-error does not know it's an array
        if (!val || !(val === null || val === void 0 ? void 0 : val.length)) {
            throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(field)}`);
        }
    }
    return true;
};
exports.validateObject = validateObject;
const getKeyMaterial = (invite) => {
    var _a;
    if (!((_a = invite === null || invite === void 0 ? void 0 : invite.aes256GcmHkdfSha256) === null || _a === void 0 ? void 0 : _a.keyMaterial)) {
        throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, 'Missing key material');
    }
    return invite.aes256GcmHkdfSha256.keyMaterial;
};
exports.getKeyMaterial = getKeyMaterial;
const topicDataToConversationReference = ({ invitation, createdNs, peerAddress, }) => ({
    context: invitation.context,
    topic: invitation.topic,
    peerAddress,
    createdNs,
});
exports.topicDataToConversationReference = topicDataToConversationReference;
const isCompleteTopicData = (obj) => !!obj.invitation;
exports.isCompleteTopicData = isCompleteTopicData;
const typeSafeTopicMap = (topicMap) => {
    const out = {};
    for (const [topic, topicData] of Object.entries(topicMap.topics)) {
        if ((0, exports.isCompleteTopicData)(topicData)) {
            out[topic] = topicData;
        }
        else {
            // This should only happen if bad data somehow snuck through validation
            console.warn('Invitation missing from topic data');
        }
    }
    return out;
};
exports.typeSafeTopicMap = typeSafeTopicMap;
//# sourceMappingURL=utils.js.map