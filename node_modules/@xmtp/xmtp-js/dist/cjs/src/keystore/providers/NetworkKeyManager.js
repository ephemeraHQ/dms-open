"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.storageSigRequestText = void 0;
const ethers_1 = require("ethers");
const crypto_1 = require("../../crypto");
const authn_1 = require("../../authn");
const utils_1 = require("../../crypto/utils");
const Ciphertext_1 = __importDefault(require("../../crypto/Ciphertext"));
const proto_1 = require("@xmtp/proto");
const KEY_BUNDLE_NAME = 'key_bundle';
/**
 * EncryptedKeyStore wraps Store to enable encryption of private key bundles
 * using a wallet signature.
 */
class NetworkKeyManager {
    constructor(signer, persistence) {
        this.signer = signer;
        this.persistence = persistence;
    }
    getStorageAddress(name) {
        return __awaiter(this, void 0, void 0, function* () {
            // I think we want to namespace the storage address by wallet
            // This will allow us to support switching between multiple wallets in the same browser
            let walletAddress = yield this.signer.getAddress();
            walletAddress = ethers_1.utils.getAddress(walletAddress);
            return `${walletAddress}/${name}`;
        });
    }
    // Retrieve a private key bundle for the active wallet address in the signer
    loadPrivateKeyBundle() {
        return __awaiter(this, void 0, void 0, function* () {
            const storageBuffer = yield this.persistence.getItem(yield this.getStorageAddress(KEY_BUNDLE_NAME));
            if (!storageBuffer) {
                return null;
            }
            const [bundle, needsUpdate] = yield this.fromEncryptedBytes(this.signer, Uint8Array.from(storageBuffer));
            // If a versioned bundle is not found, the legacy bundle needs to be resaved to the store in
            // the new format. Once all bundles have been upgraded, this migration code can be removed.
            if (needsUpdate) {
                yield this.storePrivateKeyBundle(bundle);
            }
            return bundle;
        });
    }
    // Store the private key bundle at an address generated based on the active wallet in the signer
    storePrivateKeyBundle(bundle) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyAddress = yield this.getStorageAddress(KEY_BUNDLE_NAME);
            const encodedBundle = yield this.toEncryptedBytes(bundle, this.signer);
            // We need to setup the Authenticator so that the underlying store can publish messages without error
            if (typeof this.persistence.setAuthenticator === 'function') {
                this.persistence.setAuthenticator(new authn_1.LocalAuthenticator(bundle.identityKey));
            }
            yield this.persistence.setItem(keyAddress, encodedBundle);
        });
    }
    // encrypts/serializes the bundle for storage
    toEncryptedBytes(bundle, wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            // serialize the contents
            const bytes = bundle.encode();
            const wPreKey = (0, utils_1.getRandomValues)(new Uint8Array(32));
            const input = storageSigRequestText(wPreKey);
            const walletAddr = yield wallet.getAddress();
            let sig = yield wallet.signMessage(input);
            // Check that the signature is correct, was created using the expected
            // input, and retry if not. This mitigates a bug in interacting with
            // LedgerLive for iOS, where the previous signature response is
            // returned in some cases.
            let address = ethers_1.utils.verifyMessage(input, sig);
            if (address !== walletAddr) {
                sig = yield wallet.signMessage(input);
                console.log('invalid signature, retrying');
                address = ethers_1.utils.verifyMessage(input, sig);
                if (address !== walletAddr) {
                    throw new Error('invalid signature');
                }
            }
            const secret = (0, utils_1.hexToBytes)(sig);
            const ciphertext = yield (0, crypto_1.encrypt)(bytes, secret);
            return proto_1.privateKey.EncryptedPrivateKeyBundle.encode({
                v1: {
                    walletPreKey: wPreKey,
                    ciphertext,
                },
            }).finish();
        });
    }
    // decrypts/deserializes the bundle from storage bytes
    fromEncryptedBytes(wallet, bytes) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [eBundle, needsUpdate] = getEncryptedBundle(bytes);
            if (!eBundle.walletPreKey) {
                throw new Error('missing wallet pre-key');
            }
            if (!((_a = eBundle.ciphertext) === null || _a === void 0 ? void 0 : _a.aes256GcmHkdfSha256)) {
                throw new Error('missing bundle ciphertext');
            }
            const secret = (0, utils_1.hexToBytes)(yield wallet.signMessage(storageSigRequestText(eBundle.walletPreKey)));
            // Ledger uses the last byte = v=[0,1,...] but Metamask and other wallets generate with
            // v+27 as the last byte. We need to support both for interoperability. Doing this
            // on the decryption side provides an immediate retroactive fix.
            // Ledger is using the canonical way, whereas Ethereum adds 27 due to some legacy stuff
            // https://github.com/ethereum/go-ethereum/issues/19751#issuecomment-504900739
            try {
                // Try the original version of the signature first
                const ciphertext = new Ciphertext_1.default(eBundle.ciphertext);
                const decrypted = yield (0, crypto_1.decrypt)(ciphertext, secret);
                const [bundle, needsUpdate2] = getPrivateBundle(decrypted);
                return [bundle, needsUpdate || needsUpdate2];
            }
            catch (e) {
                // Assert that the secret is length 65 (encoded signature + recovery byte)
                if (secret.length !== 65) {
                    throw new Error('Expected 65 bytes before trying a different recovery byte');
                }
                // Try the other version of recovery byte, either +27 or -27
                const lastByte = secret[secret.length - 1];
                let newSecret = secret.slice(0, secret.length - 1);
                if (lastByte < 27) {
                    // This is a canonical signature, so we need to add 27 to the recovery byte and try again
                    newSecret = new Uint8Array([...newSecret, lastByte + 27]);
                }
                else {
                    // This canocalizes v to 0 or 1 (or maybe 2 or 3 but very unlikely)
                    newSecret = new Uint8Array([...newSecret, lastByte - 27]);
                }
                const ciphertext = new Ciphertext_1.default(eBundle.ciphertext);
                const decrypted = yield (0, crypto_1.decrypt)(ciphertext, newSecret);
                const [bundle, needsUpdate2] = getPrivateBundle(decrypted);
                return [bundle, needsUpdate || needsUpdate2];
            }
        });
    }
}
exports.default = NetworkKeyManager;
// getEncryptedV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts
// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.
function getEncryptedBundle(bytes) {
    try {
        const b = proto_1.privateKey.EncryptedPrivateKeyBundle.decode(bytes);
        if (b.v1) {
            return [b.v1, false];
        }
    }
    catch (e) {
        return [proto_1.privateKey.EncryptedPrivateKeyBundleV1.decode(bytes), true];
    }
    throw new Error('unrecognized encrypted private key bundle version');
}
// getPrivateV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts
// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.
function getPrivateBundle(bytes) {
    try {
        // TODO: add support for V2
        const b = (0, crypto_1.decodePrivateKeyBundle)(bytes);
        if (b instanceof crypto_1.PrivateKeyBundleV2) {
            throw new Error('V2 bundles not supported yet');
        }
        return [b, false];
    }
    catch (e) {
        // Adds a default fallback for older versions of the proto
        const b = proto_1.privateKey.PrivateKeyBundleV1.decode(bytes);
        return [new crypto_1.PrivateKeyBundleV1(b), true];
    }
}
function storageSigRequestText(preKey) {
    // Note that an update to this signature request text will require
    // addition of backward compatibility for existing encrypted bundles
    // and/or a migration; otherwise clients will no longer be able to
    // decrypt those bundles.
    return ('XMTP : Enable Identity\n' +
        `${(0, utils_1.bytesToHex)(preKey)}\n` +
        '\n' +
        'For more info: https://xmtp.org/signatures/');
}
exports.storageSigRequestText = storageSigRequestText;
//# sourceMappingURL=NetworkKeyManager.js.map