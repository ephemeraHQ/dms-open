"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Stream implements an Asynchronous Iterable over messages received from a topic.
 * As such can be used with constructs like for-await-of, yield*, array destructing, etc.
 */
class Stream {
    constructor(client, topics, decoder, contentTopicUpdater) {
        this.messages = [];
        this.resolvers = [];
        this.topics = topics;
        this.client = client;
        this.callback = this.newMessageCallback(decoder, contentTopicUpdater);
    }
    // returns new closure to handle incoming messages
    newMessageCallback(decoder, contentTopicUpdater) {
        return (env) => __awaiter(this, void 0, void 0, function* () {
            if (!env.message) {
                return;
            }
            try {
                const msg = yield decoder(env);
                // decoder can return undefined to signal a message to ignore/skip.
                if (!msg) {
                    return;
                }
                // Check to see if we should update the stream's content topic subscription
                if (contentTopicUpdater) {
                    const topics = contentTopicUpdater(msg);
                    if (topics) {
                        this.resubscribeToTopics(topics);
                    }
                }
                // is there a Promise already pending?
                const resolver = this.resolvers.pop();
                if (resolver) {
                    // yes, resolve it
                    resolver({ value: msg });
                }
                else {
                    // no, push the message into the queue
                    this.messages.unshift(msg);
                }
            }
            catch (e) {
                console.warn(e);
            }
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.callback) {
                throw new Error('Missing callback for stream');
            }
            this.unsubscribeFn = this.client.apiClient.subscribe({
                contentTopics: this.topics,
            }, (env) => __awaiter(this, void 0, void 0, function* () {
                if (!this.callback)
                    return;
                yield (this === null || this === void 0 ? void 0 : this.callback(env));
            }));
        });
    }
    static create(client, topics, decoder, contentTopicUpdater) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = new Stream(client, topics, decoder, contentTopicUpdater);
            yield stream.start();
            return stream;
        });
    }
    // To make Stream proper Async Iterable
    [Symbol.asyncIterator]() {
        return this;
    }
    // return should be called if the interpreter detects that the stream won't be used anymore,
    // e.g. a for/of loop was exited via a break. It can also be called explicitly.
    // https://tc39.es/ecma262/#table-iterator-interface-optional-properties
    // Note that this means the Stream will be closed after it was used in a for-await-of or yield* or similar.
    return() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.unsubscribeFn) {
                yield this.unsubscribeFn();
            }
            if (!this.callback) {
                return { value: undefined, done: true };
            }
            this.callback = undefined;
            this.resolvers.forEach((resolve) => resolve({ value: undefined, done: true }));
            return { value: undefined, done: true };
        });
    }
    // To make Stream proper Async Iterator
    // Note that next() will still provide whatever messages were already pending
    // even after the stream was closed via return().
    next() {
        // Is there a message already pending?
        const msg = this.messages.pop();
        if (msg) {
            // yes, return resolved promise
            return Promise.resolve({ value: msg });
        }
        if (!this.callback) {
            return Promise.resolve({ value: undefined, done: true });
        }
        // otherwise return empty Promise and queue its resolver
        return new Promise((resolve) => this.resolvers.unshift(resolve));
    }
    // Unsubscribe from the existing content topics and resubscribe to the given topics.
    resubscribeToTopics(topics) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.callback || !this.unsubscribeFn) {
                throw new Error('Missing callback for stream');
            }
            yield this.unsubscribeFn();
            this.topics = topics;
            this.unsubscribeFn = this.client.apiClient.subscribe({
                contentTopics: this.topics,
            }, (env) => __awaiter(this, void 0, void 0, function* () {
                if (!this.callback)
                    return;
                yield (this === null || this === void 0 ? void 0 : this.callback(env));
            }));
        });
    }
}
exports.default = Stream;
//# sourceMappingURL=Stream.js.map