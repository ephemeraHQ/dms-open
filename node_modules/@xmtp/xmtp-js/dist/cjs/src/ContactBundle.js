"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeContactBundle = exports.decodeContactBundle = void 0;
const proto_1 = require("@xmtp/proto");
const crypto_1 = require("./crypto");
// Decodes contact bundles from the contact topic.
function decodeContactBundle(bytes) {
    var _a, _b;
    let cb;
    try {
        cb = proto_1.contact.ContactBundle.decode(bytes);
    }
    catch (e) {
        const pb = proto_1.publicKey.PublicKeyBundle.decode(bytes);
        cb = { v1: { keyBundle: new crypto_1.PublicKeyBundle(pb) }, v2: undefined };
    }
    if ((_a = cb.v1) === null || _a === void 0 ? void 0 : _a.keyBundle) {
        return new crypto_1.PublicKeyBundle(cb.v1.keyBundle);
    }
    if ((_b = cb.v2) === null || _b === void 0 ? void 0 : _b.keyBundle) {
        return new crypto_1.SignedPublicKeyBundle(cb.v2.keyBundle);
    }
    throw new Error('unknown or invalid contact bundle');
}
exports.decodeContactBundle = decodeContactBundle;
// Encodes public key bundle for the contact topic.
function encodeContactBundle(bundle) {
    if (bundle instanceof crypto_1.PublicKeyBundle) {
        return proto_1.contact.ContactBundle.encode({
            v1: { keyBundle: bundle },
            v2: undefined,
        }).finish();
    }
    else {
        return proto_1.contact.ContactBundle.encode({
            v1: undefined,
            v2: { keyBundle: bundle },
        }).finish();
    }
}
exports.encodeContactBundle = encodeContactBundle;
//# sourceMappingURL=ContactBundle.js.map