var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import { Mutex } from 'async-mutex';
import { SignedPublicKeyBundle } from './../crypto/PublicKeyBundle';
import { ConversationV1, ConversationV2 } from './Conversation';
import { MessageV1, DecodedMessage } from '../Message';
import Stream from '../Stream';
import { b64Decode, buildUserIntroTopic, buildUserInviteTopic, dateToNs, nsToDate, } from '../utils';
import { PublicKeyBundle } from '../crypto';
import { SortDirection } from '../ApiClient';
import Long from 'long';
const CLOCK_SKEW_OFFSET_MS = 10000;
const messageHasHeaders = (msg) => {
    return Boolean(msg.recipientAddress && msg.senderAddress);
};
export class ConversationCache {
    constructor() {
        this.conversations = [];
        this.mutex = new Mutex();
        this.seenTopics = new Set();
    }
    load(loader) {
        return __awaiter(this, void 0, void 0, function* () {
            const release = yield this.mutex.acquire();
            try {
                const newConvos = yield loader({
                    latestSeen: this.latestSeen,
                    existing: this.conversations,
                });
                for (const convo of newConvos) {
                    if (!this.seenTopics.has(convo.topic)) {
                        this.seenTopics.add(convo.topic);
                        this.conversations.push(convo);
                        if (!this.latestSeen || convo.createdAt > this.latestSeen) {
                            this.latestSeen = convo.createdAt;
                        }
                    }
                }
                // No catch block so that errors still bubble
            }
            finally {
                release();
            }
            return [...this.conversations];
        });
    }
}
/**
 * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet
 */
export default class Conversations {
    constructor(client) {
        this.client = client;
        this.v1Cache = new ConversationCache();
        this.v2Mutex = new Mutex();
    }
    /**
     * List all conversations with the current wallet found in the network.
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const [v1Convos, v2Convos] = yield Promise.all([
                this.listV1Conversations(),
                this.listV2Conversations(),
            ]);
            const conversations = v1Convos.concat(v2Convos);
            conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
            return conversations;
        });
    }
    listV1Conversations() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v1Cache.load(({ latestSeen }) => __awaiter(this, void 0, void 0, function* () {
                const seenPeers = yield this.getIntroductionPeers({
                    startTime: latestSeen
                        ? new Date(+latestSeen - CLOCK_SKEW_OFFSET_MS)
                        : undefined,
                    direction: SortDirection.SORT_DIRECTION_ASCENDING,
                });
                return Array.from(seenPeers).map(([peerAddress, sent]) => new ConversationV1(this.client, peerAddress, sent));
            }));
        });
    }
    /**
     * List all V2 conversations
     */
    listV2Conversations() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v2Mutex.runExclusive(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                // Get all conversations already in the KeyStore
                const existing = yield this.getV2ConversationsFromKeystore();
                const latestConversationTime = (_a = existing[existing.length - 1]) === null || _a === void 0 ? void 0 : _a.createdAt;
                // Load all conversations started after the newest conversation found
                const newConversations = yield this.updateV2Conversations(latestConversationTime);
                // Create a Set of all the existing topics to ensure no duplicates are added
                const existingTopics = new Set(existing.map((c) => c.topic));
                // Add all new conversations to the existing list
                for (const convo of newConversations) {
                    if (!existingTopics.has(convo.topic)) {
                        existing.push(convo);
                        existingTopics.add(convo.topic);
                    }
                }
                // Sort the result set by creation time in ascending order
                existing.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
                return existing;
            }));
        });
    }
    getV2ConversationsFromKeystore() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.client.keystore.getV2Conversations()).map(this.conversationReferenceToV2.bind(this));
        });
    }
    // Called in listV2Conversations and in newConversation
    updateV2Conversations(startTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const envelopes = yield this.client.listInvitations({
                startTime: startTime
                    ? new Date(+startTime - CLOCK_SKEW_OFFSET_MS)
                    : undefined,
                direction: SortDirection.SORT_DIRECTION_ASCENDING,
            });
            return this.decodeInvites(envelopes);
        });
    }
    decodeInvites(envelopes, shouldThrow = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const { responses } = yield this.client.keystore.saveInvites({
                requests: envelopes.map((env) => ({
                    payload: b64Decode(env.message),
                    timestampNs: Long.fromString(env.timestampNs),
                    contentTopic: env.contentTopic,
                })),
            });
            const out = [];
            for (const response of responses) {
                try {
                    const convo = this.saveInviteResponseToConversation(response);
                    out.push(convo);
                }
                catch (e) {
                    console.warn('Error saving invite response to conversation: ', e);
                    if (shouldThrow) {
                        throw e;
                    }
                }
            }
            return out;
        });
    }
    saveInviteResponseToConversation({ result, error, }) {
        if (error || !result || !result.conversation) {
            throw new Error(`Error from keystore: ${error === null || error === void 0 ? void 0 : error.code} ${error === null || error === void 0 ? void 0 : error.message}}`);
        }
        return this.conversationReferenceToV2(result.conversation);
    }
    conversationReferenceToV2(convoRef) {
        return new ConversationV2(this.client, convoRef.topic, convoRef.peerAddress, nsToDate(convoRef.createdNs), convoRef.context);
    }
    /**
     * Returns a stream of any newly created conversations.
     * Will dedupe to not return the same conversation twice in the same stream.
     * Does not dedupe any other previously seen conversations
     */
    stream() {
        return __awaiter(this, void 0, void 0, function* () {
            const seenPeers = new Set();
            const introTopic = buildUserIntroTopic(this.client.address);
            const inviteTopic = buildUserInviteTopic(this.client.address);
            const newPeer = (peerAddress) => {
                // Check if we have seen the peer already in this stream
                if (seenPeers.has(peerAddress)) {
                    return false;
                }
                seenPeers.add(peerAddress);
                return true;
            };
            const decodeConversation = (env) => __awaiter(this, void 0, void 0, function* () {
                if (env.contentTopic === introTopic) {
                    const messageBytes = b64Decode(env.message);
                    const msg = yield MessageV1.fromBytes(messageBytes);
                    const peerAddress = this.getPeerAddress(msg);
                    if (!newPeer(peerAddress)) {
                        return undefined;
                    }
                    yield msg.decrypt(this.client.keystore, this.client.publicKeyBundle);
                    return new ConversationV1(this.client, peerAddress, msg.sent);
                }
                if (env.contentTopic === inviteTopic) {
                    const results = yield this.decodeInvites([env], true);
                    if (results.length) {
                        return results[0];
                    }
                }
                throw new Error('unrecognized invite topic');
            });
            return Stream.create(this.client, [inviteTopic, introTopic], decodeConversation.bind(this));
        });
    }
    /**
     * Streams messages from all conversations.
     *
     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
     *
     */
    streamAllMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            const introTopic = buildUserIntroTopic(this.client.address);
            const inviteTopic = buildUserInviteTopic(this.client.address);
            const topics = new Set([introTopic, inviteTopic]);
            const convoMap = new Map();
            for (const conversation of yield this.list()) {
                topics.add(conversation.topic);
                convoMap.set(conversation.topic, conversation);
            }
            const decodeMessage = (env) => __awaiter(this, void 0, void 0, function* () {
                const contentTopic = env.contentTopic;
                if (!contentTopic) {
                    return null;
                }
                if (contentTopic === introTopic) {
                    const messageBytes = b64Decode(env.message);
                    const msg = yield MessageV1.fromBytes(messageBytes);
                    if (!messageHasHeaders(msg)) {
                        return null;
                    }
                    const peerAddress = this.getPeerAddress(msg);
                    // Temporarily create a convo to decrypt the message
                    const convo = new ConversationV1(this.client, peerAddress, msg.sent);
                    // TODO: This duplicates the proto deserialization unnecessarily
                    // Refactor to avoid duplicate work
                    return convo.decodeMessage(env);
                }
                // Decode as an invite and return the envelope
                // This gives the contentTopicUpdater everything it needs to add to the topic list
                if (contentTopic === inviteTopic) {
                    const results = yield this.decodeInvites([env], true);
                    return results[0];
                }
                const convo = convoMap.get(contentTopic);
                // Decode as a V1 message if the topic matches a V1 convo
                if (convo instanceof ConversationV1) {
                    return convo.decodeMessage(env);
                }
                // Decode as a V2 message if the topic matches a V2 convo
                if (convo instanceof ConversationV2) {
                    return convo.decodeMessage(env);
                }
                console.log('Unknown topic');
                throw new Error('Unknown topic');
            });
            const addConvo = (topic, conversation) => {
                if (topics.has(topic)) {
                    return false;
                }
                convoMap.set(topic, conversation);
                topics.add(topic);
                return true;
            };
            const contentTopicUpdater = (msg) => {
                // If we have a V1 message from the introTopic, store the conversation in our mapping
                if (msg instanceof DecodedMessage && msg.contentTopic === introTopic) {
                    const convo = new ConversationV1(this.client, msg.recipientAddress === this.client.address
                        ? msg.senderAddress
                        : msg.recipientAddress, msg.sent);
                    const isNew = addConvo(convo.topic, convo);
                    return isNew ? Array.from(topics.values()) : undefined;
                }
                if (msg instanceof ConversationV2) {
                    const isNew = addConvo(msg.topic, msg);
                    return isNew ? Array.from(topics.values()) : undefined;
                }
                return undefined;
            };
            const str = yield Stream.create(this.client, Array.from(topics.values()), decodeMessage, contentTopicUpdater);
            return (function generate() {
                return __asyncGenerator(this, arguments, function* generate_1() {
                    var e_1, _a;
                    try {
                        for (var str_1 = __asyncValues(str), str_1_1; str_1_1 = yield __await(str_1.next()), !str_1_1.done;) {
                            const val = str_1_1.value;
                            if (val instanceof DecodedMessage) {
                                yield yield __await(val);
                            }
                            // For conversation V2, we may have messages in the new topic before we started streaming.
                            // To be safe, we fetch all messages
                            if (val instanceof ConversationV2) {
                                for (const convoMessage of yield __await(val.messages())) {
                                    yield yield __await(convoMessage);
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) yield __await(_a.call(str_1));
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                });
            })();
        });
    }
    getIntroductionPeers(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const topic = buildUserIntroTopic(this.client.address);
            const messages = yield this.client.listEnvelopes(topic, (env) => {
                return MessageV1.fromBytes(b64Decode(env.message));
            }, opts);
            const seenPeers = new Map();
            for (const message of messages) {
                // Ignore all messages without sender or recipient address headers
                // Makes getPeerAddress safe
                if (!messageHasHeaders(message)) {
                    continue;
                }
                const peerAddress = this.getPeerAddress(message);
                if (peerAddress) {
                    const have = seenPeers.get(peerAddress);
                    if (!have || have > message.sent) {
                        try {
                            // Verify that the message can be decrypted before treating the intro as valid
                            yield message.decrypt(this.client.keystore, this.client.publicKeyBundle);
                            seenPeers.set(peerAddress, message.sent);
                        }
                        catch (e) {
                            continue;
                        }
                    }
                }
            }
            return seenPeers;
        });
    }
    /**
     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
     */
    newConversation(peerAddress, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let contact = yield this.client.getUserContact(peerAddress);
            if (!contact) {
                throw new Error(`Recipient ${peerAddress} is not on the XMTP network`);
            }
            // If this is a V1 conversation continuation
            if (contact instanceof PublicKeyBundle && !(context === null || context === void 0 ? void 0 : context.conversationId)) {
                return new ConversationV1(this.client, peerAddress, new Date());
            }
            // If no conversationId, check and see if we have an existing V1 conversation
            if (!(context === null || context === void 0 ? void 0 : context.conversationId)) {
                const v1Convos = yield this.listV1Conversations();
                const matchingConvo = v1Convos.find((convo) => convo.peerAddress === peerAddress);
                // If intro already exists, return V1 conversation
                // if both peers have V1 compatible key bundles
                if (matchingConvo) {
                    if (!this.client.signedPublicKeyBundle.isFromLegacyBundle()) {
                        throw new Error('cannot resume pre-existing V1 conversation; client keys not compatible');
                    }
                    if (!(contact instanceof PublicKeyBundle) &&
                        !contact.isFromLegacyBundle()) {
                        throw new Error('cannot resume pre-existing V1 conversation; peer keys not compatible');
                    }
                    return matchingConvo;
                }
            }
            // Coerce the contact into a V2 bundle
            if (contact instanceof PublicKeyBundle) {
                contact = SignedPublicKeyBundle.fromLegacyBundle(contact);
            }
            // Define a function for matching V2 conversations
            const matcherFn = (convo) => {
                var _a;
                return convo.peerAddress === peerAddress &&
                    isMatchingContext(context, (_a = convo.context) !== null && _a !== void 0 ? _a : undefined);
            };
            return this.v2Mutex.runExclusive(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const existing = yield this.getV2ConversationsFromKeystore();
                const existingMatch = existing.find(matcherFn);
                if (existingMatch) {
                    return existingMatch;
                }
                const latestSeen = (_a = existing[existing.length - 1]) === null || _a === void 0 ? void 0 : _a.createdAt;
                const newItems = yield this.updateV2Conversations(latestSeen);
                const newItemMatch = newItems.find(matcherFn);
                // If one of those matches, return it to update the cache
                if (newItemMatch) {
                    return newItemMatch;
                }
                return this.createV2Convo(contact, context);
            }));
        });
    }
    createV2Convo(recipient, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const timestamp = new Date();
            const { payload, conversation } = yield this.client.keystore.createInvite({
                recipient,
                context,
                createdNs: dateToNs(timestamp),
            });
            if (!payload || !conversation) {
                throw new Error('Required field not returned from Keystore');
            }
            const peerAddress = yield recipient.walletSignatureAddress();
            yield this.client.publishEnvelopes([
                {
                    contentTopic: buildUserInviteTopic(peerAddress),
                    message: payload,
                    timestamp,
                },
                {
                    contentTopic: buildUserInviteTopic(this.client.address),
                    message: payload,
                    timestamp,
                },
            ]);
            return this.conversationReferenceToV2(conversation);
        });
    }
    getPeerAddress(message) {
        const peerAddress = message.recipientAddress === this.client.address
            ? message.senderAddress
            : message.recipientAddress;
        // This assertion is safe, so long as messages have been through the filter
        return peerAddress;
    }
}
function isMatchingContext(contextA, contextB) {
    // Use == to allow null and undefined to be equivalent
    return (contextA === null || contextA === void 0 ? void 0 : contextA.conversationId) === (contextB === null || contextB === void 0 ? void 0 : contextB.conversationId);
}
//# sourceMappingURL=Conversations.js.map