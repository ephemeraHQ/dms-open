import { publicKey } from '@xmtp/proto';
import { AccountLinkedPublicKey, PublicKey, SignedPublicKey } from './PublicKey';
export class SignedPublicKeyBundleV2 {
    constructor(bundle) {
        if (!bundle.accountLinkedKey) {
            throw new Error('SignedPublicKeyBundleV2 missing account linked key');
        }
        if (!bundle.preKey) {
            throw new Error('SignedPublicKeyBundleV2 missing pre-key');
        }
        this.accountLinkedKey = new AccountLinkedPublicKey(bundle.accountLinkedKey);
        this.preKey = new SignedPublicKey(bundle.preKey);
    }
    getLinkedAddress(role) {
        return this.accountLinkedKey.getLinkedAddress(role);
    }
    equals(other) {
        return (this.accountLinkedKey.equals(other.accountLinkedKey) &&
            this.preKey.equals(other.preKey));
    }
}
// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.
// The PreKey must be signed by the IdentityKey.
// The IdentityKey must be signed by the wallet to authenticate it.
export class SignedPublicKeyBundle {
    constructor(bundle) {
        if (!bundle.identityKey) {
            throw new Error('missing identity key');
        }
        if (!bundle.preKey) {
            throw new Error('missing pre-key');
        }
        this.identityKey = new SignedPublicKey(bundle.identityKey);
        this.preKey = new SignedPublicKey(bundle.preKey);
    }
    walletSignatureAddress() {
        return this.identityKey.walletSignatureAddress();
    }
    equals(other) {
        return (this.identityKey.equals(other.identityKey) &&
            this.preKey.equals(other.preKey));
    }
    toBytes() {
        return publicKey.SignedPublicKeyBundle.encode(this).finish();
    }
    isFromLegacyBundle() {
        return this.identityKey.isFromLegacyKey() && this.preKey.isFromLegacyKey();
    }
    toLegacyBundle() {
        return new PublicKeyBundle({
            identityKey: this.identityKey.toLegacyKey(),
            preKey: this.preKey.toLegacyKey(),
        });
    }
    static fromBytes(bytes) {
        const decoded = publicKey.SignedPublicKeyBundle.decode(bytes);
        return new SignedPublicKeyBundle(decoded);
    }
    static fromLegacyBundle(bundle) {
        return new SignedPublicKeyBundle({
            // Note: I am assuming all PublicKeyBundles passed into this have had their identity keys signed by a wallet
            // Maybe that is not universally true in the future
            identityKey: SignedPublicKey.fromLegacyKey(bundle.identityKey, true),
            preKey: SignedPublicKey.fromLegacyKey(bundle.preKey),
        });
    }
}
// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.
// The PreKey must be signed by the IdentityKey.
// The IdentityKey can be signed by the wallet to authenticate it.
export class PublicKeyBundle {
    constructor(bundle) {
        if (!bundle.identityKey) {
            throw new Error('missing identity key');
        }
        if (!bundle.preKey) {
            throw new Error('missing pre-key');
        }
        this.identityKey = new PublicKey(bundle.identityKey);
        this.preKey = new PublicKey(bundle.preKey);
    }
    equals(other) {
        return (this.identityKey.equals(other.identityKey) &&
            this.preKey.equals(other.preKey));
    }
    walletSignatureAddress() {
        return this.identityKey.walletSignatureAddress();
    }
    toBytes() {
        return publicKey.PublicKeyBundle.encode(this).finish();
    }
    static fromBytes(bytes) {
        const decoded = publicKey.PublicKeyBundle.decode(bytes);
        return new PublicKeyBundle(decoded);
    }
}
//# sourceMappingURL=PublicKeyBundle.js.map