var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import { messageApi } from '@xmtp/proto';
import { retry, sleep, toNanoString } from './utils';
import AuthCache from './authn/AuthCache';
import { version } from '../package.json';
import { XMTP_DEV_WARNING } from './constants';
export const { MessageApi, SortDirection } = messageApi;
const RETRY_SLEEP_TIME = 100;
const ERR_CODE_UNAUTHENTICATED = 16;
const clientVersionHeaderKey = 'X-Client-Version';
const appVersionHeaderKey = 'X-App-Version';
export const ApiUrls = {
    local: 'http://localhost:5555',
    dev: 'https://dev.xmtp.network',
    production: 'https://production.xmtp.network',
};
export var GrpcStatus;
(function (GrpcStatus) {
    GrpcStatus[GrpcStatus["OK"] = 0] = "OK";
    GrpcStatus[GrpcStatus["CANCELLED"] = 1] = "CANCELLED";
    GrpcStatus[GrpcStatus["UNKNOWN"] = 2] = "UNKNOWN";
    GrpcStatus[GrpcStatus["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    GrpcStatus[GrpcStatus["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    GrpcStatus[GrpcStatus["NOT_FOUND"] = 5] = "NOT_FOUND";
    GrpcStatus[GrpcStatus["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    GrpcStatus[GrpcStatus["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    GrpcStatus[GrpcStatus["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    GrpcStatus[GrpcStatus["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    GrpcStatus[GrpcStatus["ABORTED"] = 10] = "ABORTED";
    GrpcStatus[GrpcStatus["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    GrpcStatus[GrpcStatus["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    GrpcStatus[GrpcStatus["INTERNAL"] = 13] = "INTERNAL";
    GrpcStatus[GrpcStatus["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    GrpcStatus[GrpcStatus["DATA_LOSS"] = 15] = "DATA_LOSS";
    GrpcStatus[GrpcStatus["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(GrpcStatus || (GrpcStatus = {}));
const isAbortError = (err) => {
    if (!err) {
        return false;
    }
    if (err.name === 'AbortError' || err.message.includes('aborted')) {
        return true;
    }
    return false;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isAuthError = (err) => {
    if (err && err.code === ERR_CODE_UNAUTHENTICATED) {
        return true;
    }
    return false;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isNotAuthError = (err) => !isAuthError(err);
/**
 * ApiClient provides a wrapper for calling the GRPC Gateway generated code.
 * It adds some helpers for dealing with paginated data and automatically retries idempotent calls
 */
export default class ApiClient {
    constructor(pathPrefix, opts) {
        this.pathPrefix = pathPrefix;
        this.maxRetries = (opts === null || opts === void 0 ? void 0 : opts.maxRetries) || 5;
        this.appVersion = opts === null || opts === void 0 ? void 0 : opts.appVersion;
        this.version = 'xmtp-js/' + version;
        if (pathPrefix === ApiUrls.dev) {
            console.info(XMTP_DEV_WARNING);
        }
    }
    // Raw method for querying the API
    _query(req) {
        return retry(MessageApi.Query, [
            req,
            {
                pathPrefix: this.pathPrefix,
                mode: 'cors',
                headers: this.headers(),
            },
        ], this.maxRetries, RETRY_SLEEP_TIME);
    }
    // Raw method for batch-querying the API
    _batchQuery(req) {
        return retry(MessageApi.BatchQuery, [
            req,
            {
                pathPrefix: this.pathPrefix,
                mode: 'cors',
                headers: this.headers(),
            },
        ], this.maxRetries, RETRY_SLEEP_TIME);
    }
    // Raw method for publishing to the API
    _publish(req, attemptNumber = 0) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const authToken = yield this.getToken();
            const headers = this.headers();
            headers.set('Authorization', `Bearer ${authToken}`);
            try {
                return yield retry(MessageApi.Publish, [
                    req,
                    {
                        pathPrefix: this.pathPrefix,
                        mode: 'cors',
                        headers,
                    },
                ], this.maxRetries, RETRY_SLEEP_TIME, 
                // Do not retry UnauthenticatedErrors
                isNotAuthError);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (e) {
                // Try at most 2X. If refreshing the auth token doesn't work the first time, it won't work the second time
                if (isNotAuthError(e) || attemptNumber >= 1) {
                    throw e;
                }
                yield ((_a = this.authCache) === null || _a === void 0 ? void 0 : _a.refresh());
                return this._publish(req, attemptNumber + 1);
            }
        });
    }
    // Raw method for subscribing
    _subscribe(req, cb) {
        const abortController = new AbortController();
        const doSubscribe = () => __awaiter(this, void 0, void 0, function* () {
            while (true) {
                const startTime = new Date().getTime();
                try {
                    yield MessageApi.Subscribe(req, cb, {
                        pathPrefix: this.pathPrefix,
                        signal: abortController.signal,
                        mode: 'cors',
                        headers: this.headers(),
                    });
                    if (abortController.signal.aborted) {
                        return;
                    }
                    console.info('Stream connection closed. Resubscribing');
                    if (new Date().getTime() - startTime < 1000) {
                        yield sleep(1000);
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                }
                catch (err) {
                    if (isAbortError(err) || abortController.signal.aborted) {
                        return;
                    }
                    console.info('Stream connection closed. Resubscribing', err.toString());
                    if (new Date().getTime() - startTime < 1000) {
                        yield sleep(1000);
                    }
                }
            }
        });
        doSubscribe();
        return () => __awaiter(this, void 0, void 0, function* () {
            abortController === null || abortController === void 0 ? void 0 : abortController.abort();
        });
    }
    // Use the Query API to return the full contents of any specified topics
    query(params, { direction = SortDirection.SORT_DIRECTION_ASCENDING, limit, }) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const out = [];
            try {
                // Use queryIteratePages for better performance. 1/100th the number of Promises to resolve compared to queryStream
                for (var _b = __asyncValues(this.queryIteratePages(params, {
                    direction,
                    // If there is a limit of < 100, use that as the page size. Otherwise use 100 and stop if/when limit reached.
                    pageSize: limit && limit < 100 ? limit : 100,
                })), _c; _c = yield _b.next(), !_c.done;) {
                    const page = _c.value;
                    for (const envelope of page) {
                        out.push(envelope);
                        if (limit && out.length === limit) {
                            return out;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return out;
        });
    }
    // Will produce an AsyncGenerator of Envelopes
    // Uses queryStreamPages under the hood
    queryIterator(params, options) {
        return __asyncGenerator(this, arguments, function* queryIterator_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.queryIteratePages(params, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const envelope of page) {
                        yield yield __await(envelope);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    // Creates an async generator that will paginate through the Query API until it reaches the end
    // Will yield each page of results as needed
    queryIteratePages({ contentTopic, startTime, endTime }, { direction, pageSize = 10 }) {
        var _a, _b, _c;
        return __asyncGenerator(this, arguments, function* queryIteratePages_1() {
            if (!contentTopic || !contentTopic.length) {
                throw new Error('Must specify content topics');
            }
            const startTimeNs = toNanoString(startTime);
            const endTimeNs = toNanoString(endTime);
            let cursor;
            while (true) {
                const pagingInfo = {
                    limit: pageSize,
                    direction,
                    cursor,
                };
                const result = yield __await(this._query({
                    contentTopics: [contentTopic],
                    startTimeNs,
                    endTimeNs,
                    pagingInfo,
                }));
                if ((_a = result.envelopes) === null || _a === void 0 ? void 0 : _a.length) {
                    yield yield __await(result.envelopes);
                }
                else {
                    return yield __await(void 0);
                }
                if ((_b = result.pagingInfo) === null || _b === void 0 ? void 0 : _b.cursor) {
                    cursor = (_c = result.pagingInfo) === null || _c === void 0 ? void 0 : _c.cursor;
                }
                else {
                    return yield __await(void 0);
                }
            }
        });
    }
    // Take a list of queries and execute them in batches
    batchQuery(queries) {
        return __awaiter(this, void 0, void 0, function* () {
            // Group queries into batches of 50 (implicit server-side limit) and then perform BatchQueries
            const BATCH_SIZE = 50;
            // Keep a list of BatchQueryRequests to execute all at once later
            const batchRequests = [];
            // Assemble batches
            for (let i = 0; i < queries.length; i += BATCH_SIZE) {
                const queriesInBatch = queries.slice(i, i + BATCH_SIZE);
                // Perform batch query by first compiling a list of repeated individual QueryRequests
                // then populating a BatchQueryRequest with that list
                const constructedQueries = [];
                for (const queryParams of queriesInBatch) {
                    constructedQueries.push({
                        contentTopics: [queryParams.contentTopic],
                        startTimeNs: toNanoString(queryParams.startTime),
                        endTimeNs: toNanoString(queryParams.endTime),
                        pagingInfo: {
                            limit: queryParams.pageSize || 10,
                            direction: queryParams.direction || SortDirection.SORT_DIRECTION_ASCENDING,
                        },
                    });
                }
                const batchQueryRequest = {
                    requests: constructedQueries,
                };
                batchRequests.push(batchQueryRequest);
            }
            // Execute batches
            const batchQueryResponses = yield Promise.all(batchRequests.map((batch) => __awaiter(this, void 0, void 0, function* () { return this._batchQuery(batch); })));
            // For every batch, read all responses within the batch, and add to a list of lists of envelopes
            // one top-level list for every original query
            const allEnvelopes = [];
            for (const batchResponse of batchQueryResponses) {
                if (!batchResponse.responses) {
                    // An error on any of the batch query is propagated to the caller
                    // for simplicity, rather than trying to return partial results
                    throw new Error('BatchQueryResponse missing responses');
                }
                for (const queryResponse of batchResponse.responses) {
                    if (queryResponse.envelopes) {
                        allEnvelopes.push(queryResponse.envelopes);
                    }
                    else {
                        // If no envelopes provided, then add an empty list
                        allEnvelopes.push([]);
                    }
                }
            }
            return allEnvelopes;
        });
    }
    // Publish a message to the network
    // Will convert timestamps to the appropriate format expected by the network
    publish(messages) {
        return __awaiter(this, void 0, void 0, function* () {
            const toSend = [];
            for (const { contentTopic, message, timestamp } of messages) {
                if (!contentTopic.length) {
                    throw new Error('Content topic cannot be empty string');
                }
                if (!message.length) {
                    throw new Error('0 length messages not allowed');
                }
                const dt = timestamp || new Date();
                toSend.push({
                    contentTopic,
                    timestampNs: toNanoString(dt),
                    message: Uint8Array.from(message),
                });
            }
            return this._publish({ envelopes: toSend });
        });
    }
    // Subscribe to a list of topics.
    // Provided callback function will be called on each new message
    // Returns an unsubscribe function that can be used to end the subscription
    subscribe(params, callback) {
        if (!params.contentTopics.length) {
            throw new Error('Must provide list of contentTopics to subscribe to');
        }
        return this._subscribe(params, callback);
    }
    getToken() {
        if (!this.authCache) {
            throw new Error('AuthCache is not set on API Client');
        }
        return this.authCache.getToken();
    }
    setAuthenticator(authenticator, cacheExpirySeconds) {
        this.authCache = new AuthCache(authenticator, cacheExpirySeconds);
    }
    headers() {
        const headers = new Headers();
        headers.set(clientVersionHeaderKey, this.version);
        if (this.appVersion) {
            headers.set(appVersionHeaderKey, this.appVersion);
        }
        return headers;
    }
}
//# sourceMappingURL=ApiClient.js.map