/* eslint-disable camelcase */
import { ContentTypeId, } from '../MessageContent';
import { composite as proto } from '@xmtp/proto';
// xmtp.org/composite
//
// Composite is a generic sequence of multiple parts of arbitrary content type.
// It can be nested arbitrarily (composite of composites).
export const ContentTypeComposite = new ContentTypeId({
    authorityId: 'xmtp.org',
    typeId: 'composite',
    versionMajor: 1,
    versionMinor: 0,
});
// CompositeCodec implements encoding/decoding of Composite values.
// Register this codec with the Client if you want support for Composite content.
export class CompositeCodec {
    get contentType() {
        return ContentTypeComposite;
    }
    encode(content, codecs) {
        const part = this.toProto(content, codecs);
        let composite;
        if (part.composite) {
            composite = part.composite;
        }
        else {
            composite = { parts: [part] };
        }
        const bytes = proto.Composite.encode(composite).finish();
        return {
            type: ContentTypeComposite,
            parameters: {},
            content: bytes,
        };
    }
    decode(content, codecs) {
        return this.fromProto({ composite: proto.Composite.decode(content.content), part: undefined }, codecs);
    }
    toProto(content, codecs) {
        if ('type' in content) {
            const codec = codecs.codecFor(content.type);
            if (!codec) {
                throw new Error(`missing codec for part type ${content.type}`);
            }
            return {
                part: codec.encode(content.content, codecs),
                composite: undefined,
            };
        }
        const parts = new Array();
        for (const part of content.parts) {
            parts.push(this.toProto(part, codecs));
        }
        return { composite: { parts }, part: undefined };
    }
    fromProto(content, codecs) {
        if (content.part) {
            if (!content.part.type) {
                throw new Error('missing part content type');
            }
            const contentType = new ContentTypeId(content.part.type);
            const codec = codecs.codecFor(contentType);
            if (!codec) {
                throw new Error(`missing codec for part type ${contentType}`);
            }
            return {
                type: contentType,
                content: codec.decode(content.part, codecs),
            };
        }
        if (!content.composite) {
            throw new Error('invalid composite');
        }
        const parts = new Array();
        for (const part of content.composite.parts) {
            parts.push(this.fromProto(part, codecs));
        }
        return { parts };
    }
}
//# sourceMappingURL=Composite.js.map