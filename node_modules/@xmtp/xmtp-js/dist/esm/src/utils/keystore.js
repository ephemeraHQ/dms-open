import { keystore } from '@xmtp/proto';
import { PublicKeyBundle } from '../crypto/PublicKeyBundle';
import { KeystoreError } from '../keystore/errors';
// Validates the Keystore response. Throws on errors or missing fields.
// Returns a type with all possibly undefined fields required to be defined
export const getResultOrThrow = (response) => {
    if (response.error) {
        throw new KeystoreError(response.error.code, response.error.message);
    }
    if (!response.result) {
        throw new KeystoreError(keystore.ErrorCode.ERROR_CODE_UNSPECIFIED, 'No result from Keystore');
    }
    if ('encrypted' in response.result && !response.result.encrypted) {
        throw new Error('Missing ciphertext');
    }
    if ('decrypted' in response.result && !response.result.decrypted) {
        throw new Error('Missing decrypted result');
    }
    return response.result;
};
export const buildDecryptV1Request = (messages, myPublicKeyBundle) => {
    return {
        requests: messages.map((m) => {
            var _a, _b, _c, _d;
            const sender = new PublicKeyBundle({
                identityKey: (_a = m.header.sender) === null || _a === void 0 ? void 0 : _a.identityKey,
                preKey: (_b = m.header.sender) === null || _b === void 0 ? void 0 : _b.preKey,
            });
            const isSender = myPublicKeyBundle.equals(sender);
            return {
                payload: m.ciphertext,
                peerKeys: isSender
                    ? new PublicKeyBundle({
                        identityKey: (_c = m.header.recipient) === null || _c === void 0 ? void 0 : _c.identityKey,
                        preKey: (_d = m.header.recipient) === null || _d === void 0 ? void 0 : _d.preKey,
                    })
                    : sender,
                headerBytes: m.headerBytes,
                isSender,
            };
        }),
    };
};
//# sourceMappingURL=keystore.js.map