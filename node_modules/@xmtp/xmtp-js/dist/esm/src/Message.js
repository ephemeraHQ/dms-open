var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ConversationV1, ConversationV2, } from './conversations/Conversation';
import { message as proto, content as protoContent, } from '@xmtp/proto';
import Long from 'long';
import Ciphertext from './crypto/Ciphertext';
import { PublicKeyBundle, PublicKey } from './crypto';
import { bytesToHex } from './crypto/utils';
import { sha256 } from './crypto/encryption';
import { ContentTypeFallback, ContentTypeId, } from './MessageContent';
import { dateToNs, nsToDate } from './utils';
import { decompress } from './Compression';
import { buildDecryptV1Request, getResultOrThrow } from './utils/keystore';
const headerBytesAndCiphertext = (msg) => {
    var _a, _b;
    if ((_a = msg.v1) === null || _a === void 0 ? void 0 : _a.ciphertext) {
        return [msg.v1.headerBytes, new Ciphertext(msg.v1.ciphertext)];
    }
    if ((_b = msg.v2) === null || _b === void 0 ? void 0 : _b.ciphertext) {
        return [msg.v2.headerBytes, new Ciphertext(msg.v2.ciphertext)];
    }
    throw new Error('unknown message version');
};
// Message is basic unit of communication on the network.
// Message timestamp is set by the sender.
class MessageBase {
    constructor(id, bytes, obj) {
        ;
        [this.headerBytes, this.ciphertext] = headerBytesAndCiphertext(obj);
        this.id = id;
        this.bytes = bytes;
    }
    toBytes() {
        return this.bytes;
    }
}
// Message header carries the sender and recipient keys used to protect message.
// Message timestamp is set by the sender.
export class MessageV1 extends MessageBase {
    constructor(id, bytes, obj, header, senderAddress) {
        super(id, bytes, obj);
        this.conversation = undefined;
        this.senderAddress = senderAddress;
        this.header = header;
    }
    static create(obj, header, bytes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!header.sender) {
                throw new Error('missing message sender');
            }
            const senderAddress = new PublicKeyBundle(header.sender).walletSignatureAddress();
            const id = bytesToHex(yield sha256(bytes));
            return new MessageV1(id, bytes, obj, header, senderAddress);
        });
    }
    get sent() {
        return new Date(this.header.timestamp.toNumber());
    }
    // wallet address derived from the signature of the message recipient
    get recipientAddress() {
        var _a, _b;
        if (!((_b = (_a = this.header) === null || _a === void 0 ? void 0 : _a.recipient) === null || _b === void 0 ? void 0 : _b.identityKey)) {
            return undefined;
        }
        return new PublicKey(this.header.recipient.identityKey).walletSignatureAddress();
    }
    decrypt(keystore, myPublicKeyBundle) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = (yield keystore.decryptV1(buildDecryptV1Request([this], myPublicKeyBundle))).responses;
            if (!responses.length) {
                throw new Error('No response from Keystore');
            }
            const { decrypted } = getResultOrThrow(responses[0]);
            return decrypted;
        });
    }
    static fromBytes(bytes) {
        const message = proto.Message.decode(bytes);
        const [headerBytes] = headerBytesAndCiphertext(message);
        const header = proto.MessageHeaderV1.decode(headerBytes);
        if (!header) {
            throw new Error('missing message header');
        }
        if (!header.sender) {
            throw new Error('missing message sender');
        }
        if (!header.sender.identityKey) {
            throw new Error('missing message sender identity key');
        }
        if (!header.sender.preKey) {
            throw new Error('missing message sender pre-key');
        }
        if (!header.recipient) {
            throw new Error('missing message recipient');
        }
        if (!header.recipient.identityKey) {
            throw new Error('missing message recipient identity-key');
        }
        if (!header.recipient.preKey) {
            throw new Error('missing message recipient pre-key');
        }
        return MessageV1.create(message, header, bytes);
    }
    static encode(keystore, payload, sender, recipient, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = {
                sender,
                recipient,
                timestamp: Long.fromNumber(timestamp.getTime()),
            };
            const headerBytes = proto.MessageHeaderV1.encode(header).finish();
            const results = yield keystore.encryptV1({
                requests: [
                    {
                        recipient,
                        headerBytes,
                        payload,
                    },
                ],
            });
            if (!results.responses.length) {
                throw new Error('No response from Keystore');
            }
            const { encrypted: ciphertext } = getResultOrThrow(results.responses[0]);
            const protoMsg = {
                v1: { headerBytes, ciphertext },
                v2: undefined,
            };
            const bytes = proto.Message.encode(protoMsg).finish();
            return MessageV1.create(protoMsg, header, bytes);
        });
    }
}
export class MessageV2 extends MessageBase {
    constructor(id, bytes, obj, header) {
        super(id, bytes, obj);
        this.header = header;
    }
    static create(obj, header, bytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = bytesToHex(yield sha256(bytes));
            return new MessageV2(id, bytes, obj, header);
        });
    }
    get sent() {
        return nsToDate(this.header.createdNs);
    }
}
export class DecodedMessage {
    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentBytes, contentType, contentTopic, content, sent, error, }) {
        this.id = id;
        this.messageVersion = messageVersion;
        this.senderAddress = senderAddress;
        this.recipientAddress = recipientAddress;
        this.conversation = conversation;
        this.contentType = contentType;
        this.sent = sent;
        this.error = error;
        this.content = content;
        this.contentTopic = contentTopic;
        this.contentBytes = contentBytes;
    }
    toBytes() {
        var _a;
        return proto.DecodedMessage.encode(Object.assign(Object.assign({}, this), { conversation: {
                topic: this.conversation.topic,
                context: (_a = this.conversation.context) !== null && _a !== void 0 ? _a : undefined,
                createdNs: dateToNs(this.conversation.createdAt),
                peerAddress: this.conversation.peerAddress,
            }, sentNs: dateToNs(this.sent) })).finish();
    }
    static fromBytes(data, client) {
        return __awaiter(this, void 0, void 0, function* () {
            const protoVal = proto.DecodedMessage.decode(data);
            const messageVersion = protoVal.messageVersion;
            if (messageVersion !== 'v1' && messageVersion !== 'v2') {
                throw new Error('Invalid message version');
            }
            if (!protoVal.conversation) {
                throw new Error('No conversation reference found');
            }
            const { content, contentType, error } = yield decodeContent(protoVal.contentBytes, client);
            return new DecodedMessage(Object.assign(Object.assign({}, protoVal), { content,
                contentType,
                error,
                messageVersion, sent: nsToDate(protoVal.sentNs), conversation: conversationReferenceToConversation(protoVal.conversation, client, messageVersion) }));
        });
    }
    static fromV1Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentBytes, contentTopic, conversation, error) {
        const { id, senderAddress, recipientAddress, sent } = message;
        if (!senderAddress) {
            throw new Error('Sender address is required');
        }
        return new DecodedMessage({
            id,
            messageVersion: 'v1',
            senderAddress,
            recipientAddress,
            sent,
            content,
            contentBytes,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
    static fromV2Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentTopic, contentBytes, conversation, senderAddress, error) {
        const { id, sent } = message;
        return new DecodedMessage({
            id,
            messageVersion: 'v2',
            senderAddress,
            sent,
            content,
            contentBytes,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
}
export function decodeContent(contentBytes, client) {
    return __awaiter(this, void 0, void 0, function* () {
        const encodedContent = protoContent.EncodedContent.decode(contentBytes);
        if (!encodedContent.type) {
            throw new Error('missing content type');
        }
        let content; // eslint-disable-line @typescript-eslint/no-explicit-any
        let contentType = new ContentTypeId(encodedContent.type);
        let error;
        yield decompress(encodedContent, 1000);
        const codec = client.codecFor(contentType);
        if (codec) {
            content = codec.decode(encodedContent, client);
        }
        else {
            error = new Error('unknown content type ' + contentType);
            if (encodedContent.fallback) {
                content = encodedContent.fallback;
                contentType = ContentTypeFallback;
            }
        }
        return { content, contentType, error };
    });
}
function conversationReferenceToConversation(reference, client, version) {
    if (version === 'v1') {
        return new ConversationV1(client, reference.peerAddress, nsToDate(reference.createdNs));
    }
    if (version === 'v2') {
        return new ConversationV2(client, reference.topic, reference.peerAddress, nsToDate(reference.createdNs), reference.context);
    }
    throw new Error(`Unknown conversation version ${version}`);
}
//# sourceMappingURL=Message.js.map