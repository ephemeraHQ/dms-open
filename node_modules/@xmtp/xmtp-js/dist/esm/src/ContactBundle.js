import { contact, publicKey } from '@xmtp/proto';
import { PublicKeyBundle, SignedPublicKeyBundle } from './crypto';
// Decodes contact bundles from the contact topic.
export function decodeContactBundle(bytes) {
    var _a, _b;
    let cb;
    try {
        cb = contact.ContactBundle.decode(bytes);
    }
    catch (e) {
        const pb = publicKey.PublicKeyBundle.decode(bytes);
        cb = { v1: { keyBundle: new PublicKeyBundle(pb) }, v2: undefined };
    }
    if ((_a = cb.v1) === null || _a === void 0 ? void 0 : _a.keyBundle) {
        return new PublicKeyBundle(cb.v1.keyBundle);
    }
    if ((_b = cb.v2) === null || _b === void 0 ? void 0 : _b.keyBundle) {
        return new SignedPublicKeyBundle(cb.v2.keyBundle);
    }
    throw new Error('unknown or invalid contact bundle');
}
// Encodes public key bundle for the contact topic.
export function encodeContactBundle(bundle) {
    if (bundle instanceof PublicKeyBundle) {
        return contact.ContactBundle.encode({
            v1: { keyBundle: bundle },
            v2: undefined,
        }).finish();
    }
    else {
        return contact.ContactBundle.encode({
            v1: undefined,
            v2: { keyBundle: bundle },
        }).finish();
    }
}
//# sourceMappingURL=ContactBundle.js.map