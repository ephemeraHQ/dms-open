var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { keystore } from '@xmtp/proto';
import { PrivateKeyBundleV2, PrivateKeyBundleV3, } from './../crypto/PrivateKeyBundle';
import { InvitationV1, SealedInvitation } from './../Invitation';
import { decryptV1, encryptV1, encryptV2, decryptV2 } from './encryption';
import { KeystoreError } from './errors';
import { convertError, mapAndConvertErrors, toPublicKeyBundle, toSignedPublicKeyBundle, validateObject, getKeyMaterial, topicDataToConversationReference, } from './utils';
import { nsToDate } from '../utils';
import InviteStore from './InviteStore';
import LocalAuthenticator from '../authn/LocalAuthenticator';
import { AccountLinkedRole } from '../crypto/Signature';
const { ErrorCode } = keystore;
export default class InMemoryKeystore {
    constructor(keys, inviteStore) {
        this.v1Keys = keys;
        this.v2Keys = PrivateKeyBundleV2.fromLegacyBundle(keys);
        this.inviteStore = inviteStore;
        this.authenticator = new LocalAuthenticator(keys.identityKey);
    }
    static create(keys, persistence) {
        return __awaiter(this, void 0, void 0, function* () {
            return new InMemoryKeystore(keys, yield InviteStore.create(persistence));
        });
    }
    decryptV1(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield mapAndConvertErrors(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!validateObject(req, ['payload', 'peerKeys'], ['headerBytes'])) {
                    throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'invalid');
                }
                const { payload, peerKeys, headerBytes, isSender } = req;
                const decrypted = yield decryptV1(this.v1Keys, toPublicKeyBundle(peerKeys), payload, headerBytes, isSender);
                return {
                    decrypted,
                };
            }), keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);
            return keystore.DecryptResponse.fromPartial({
                responses,
            });
        });
    }
    decryptV2(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield mapAndConvertErrors(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!validateObject(req, ['payload'], ['headerBytes'])) {
                    throw new KeystoreError(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { payload, headerBytes, contentTopic } = req;
                const topicData = this.inviteStore.lookup(contentTopic);
                if (!topicData) {
                    // This is the wrong error type. Will add to the proto repo later
                    throw new KeystoreError(keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
                }
                const decrypted = yield decryptV2(payload, getKeyMaterial(topicData.invitation), headerBytes);
                return { decrypted };
            }), ErrorCode.ERROR_CODE_UNSPECIFIED);
            return keystore.DecryptResponse.fromPartial({
                responses,
            });
        });
    }
    encryptV1(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield mapAndConvertErrors(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!validateObject(req, ['payload', 'recipient'], ['headerBytes'])) {
                    throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { recipient, payload, headerBytes } = req;
                return {
                    encrypted: yield encryptV1(this.v1Keys, toPublicKeyBundle(recipient), payload, headerBytes),
                };
            }), ErrorCode.ERROR_CODE_UNSPECIFIED);
            return keystore.EncryptResponse.fromPartial({
                responses,
            });
        });
    }
    createAuthToken({ timestampNs, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.authenticator.createToken(timestampNs ? nsToDate(timestampNs) : undefined);
        });
    }
    encryptV2(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield mapAndConvertErrors(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!validateObject(req, ['payload'], ['headerBytes'])) {
                    throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { payload, headerBytes, contentTopic } = req;
                const topicData = this.inviteStore.lookup(contentTopic);
                if (!topicData) {
                    throw new KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
                }
                return {
                    encrypted: yield encryptV2(payload, getKeyMaterial(topicData.invitation), headerBytes),
                };
            }), ErrorCode.ERROR_CODE_INVALID_INPUT);
            return keystore.EncryptResponse.fromPartial({
                responses,
            });
        });
    }
    saveInvites(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const toAdd = [];
            const responses = yield mapAndConvertErrors(req.requests, ({ payload, timestampNs }) => __awaiter(this, void 0, void 0, function* () {
                const sealed = SealedInvitation.fromBytes(payload);
                if (sealed.v1) {
                    const headerTime = sealed.v1.header.createdNs;
                    if (!headerTime.equals(timestampNs)) {
                        throw new Error('envelope and header timestamp mismatch');
                    }
                    const isSender = sealed.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle());
                    const invitation = yield sealed.v1.getInvitation(this.v2Keys);
                    const topicData = {
                        invitation,
                        createdNs: sealed.v1.header.createdNs,
                        peerAddress: isSender
                            ? yield sealed.v1.header.recipient.walletSignatureAddress()
                            : yield sealed.v1.header.sender.walletSignatureAddress(),
                    };
                    toAdd.push(topicData);
                    return {
                        conversation: topicDataToConversationReference(topicData),
                    };
                }
                else if (sealed.v2) {
                    const headerTime = sealed.v2.header.createdNs;
                    if (!headerTime.equals(timestampNs)) {
                        throw new Error('envelope and header timestamp mismatch');
                    }
                    const invitation = yield sealed.v2.getInvitation(PrivateKeyBundleV3.fromLegacyBundle(this.v2Keys, AccountLinkedRole.INBOX_KEY));
                    const selfAddress = yield this.getAccountAddress();
                    const topicData = {
                        invitation,
                        createdNs: sealed.v2.header.createdNs,
                        peerAddress: sealed.v2.header.getPeerAddress(selfAddress),
                    };
                    toAdd.push(topicData);
                    return {
                        conversation: topicDataToConversationReference(topicData),
                    };
                }
            }), ErrorCode.ERROR_CODE_INVALID_INPUT);
            yield this.inviteStore.add(toAdd);
            return keystore.SaveInvitesResponse.fromPartial({
                responses,
            });
        });
    }
    createInvite(req) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!validateObject(req, ['recipient'], [])) {
                    throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing recipient');
                }
                const invitation = InvitationV1.createRandom(req.context);
                const created = nsToDate(req.createdNs);
                const recipient = toSignedPublicKeyBundle(req.recipient);
                const sealed = yield SealedInvitation.createV1({
                    sender: this.v2Keys,
                    recipient,
                    created,
                    invitation,
                });
                const topicData = {
                    invitation,
                    createdNs: req.createdNs,
                    peerAddress: yield recipient.walletSignatureAddress(),
                };
                yield this.inviteStore.add([topicData]);
                return keystore.CreateInviteResponse.fromPartial({
                    conversation: topicDataToConversationReference(topicData),
                    payload: sealed.toBytes(),
                });
            }
            catch (e) {
                throw convertError(e, ErrorCode.ERROR_CODE_INVALID_INPUT);
            }
        });
    }
    signDigest(req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!validateObject(req, ['digest'], [])) {
                throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
            }
            const { digest, identityKey, prekeyIndex } = req;
            let key;
            if (identityKey) {
                key = this.v1Keys.identityKey;
            }
            else if (typeof prekeyIndex !== 'undefined' &&
                Number.isInteger(prekeyIndex)) {
                key = this.v1Keys.preKeys[prekeyIndex];
                if (!key) {
                    throw new KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no prekey found');
                }
            }
            else {
                throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'must specifify identityKey or prekeyIndex');
            }
            return key.sign(digest);
        });
    }
    getV2Conversations() {
        return __awaiter(this, void 0, void 0, function* () {
            const convos = this.inviteStore.topics.map((invite) => topicDataToConversationReference(invite));
            convos.sort((a, b) => a.createdNs.div(1000000).sub(b.createdNs.div(1000000)).toNumber());
            return convos;
        });
    }
    getPublicKeyBundle() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v1Keys.getPublicKeyBundle();
        });
    }
    getPrivateKeyBundle() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v1Keys;
        });
    }
    getAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.accountAddress) {
                this.accountAddress = yield this.v2Keys
                    .getPublicKeyBundle()
                    .walletSignatureAddress();
            }
            return this.accountAddress;
        });
    }
}
//# sourceMappingURL=InMemoryKeystore.js.map