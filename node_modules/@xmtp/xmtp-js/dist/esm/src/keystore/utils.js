var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { keystore } from '@xmtp/proto';
import { PublicKeyBundle, SignedPublicKeyBundle } from '../crypto';
import { KeystoreError } from './errors';
export const convertError = (e, 
// Default error code to apply to errors that don't have one
errorCode) => {
    if (e instanceof KeystoreError) {
        return e;
    }
    return new KeystoreError(errorCode, e.message);
};
export const wrapResult = (result) => ({ result });
// Map an array of items to an array of results or errors
// Transform any errors thrown into `KeystoreError`s
export const mapAndConvertErrors = (input, mapper, 
// Default error code to apply to errors that don't have one
errorCode) => {
    return Promise.all(input.map((item) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            // Be sure to await mapper result to catch errors
            return wrapResult(yield mapper(item));
        }
        catch (e) {
            return { error: convertError(e, errorCode) };
        }
    })));
};
// Wrap the bundle in our class if not already wrapped
export const toPublicKeyBundle = (bundle) => {
    if (bundle instanceof PublicKeyBundle) {
        return bundle;
    }
    return new PublicKeyBundle(bundle);
};
// Wrap the bundle in our class if not already wrapped
export const toSignedPublicKeyBundle = (bundle) => {
    if (bundle instanceof SignedPublicKeyBundle) {
        return bundle;
    }
    return new SignedPublicKeyBundle(bundle);
};
// Takes object and returns true if none of the `objectFields` are null or undefined and none of the `arrayFields` are empty
export const validateObject = (obj, objectFields, arrayFields) => {
    for (const field of objectFields) {
        if (!obj[field]) {
            throw new KeystoreError(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(field)}`);
        }
    }
    for (const field of arrayFields) {
        const val = obj[field];
        // @ts-expect-error does not know it's an array
        if (!val || !(val === null || val === void 0 ? void 0 : val.length)) {
            throw new KeystoreError(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(field)}`);
        }
    }
    return true;
};
export const getKeyMaterial = (invite) => {
    var _a;
    if (!((_a = invite === null || invite === void 0 ? void 0 : invite.aes256GcmHkdfSha256) === null || _a === void 0 ? void 0 : _a.keyMaterial)) {
        throw new KeystoreError(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, 'Missing key material');
    }
    return invite.aes256GcmHkdfSha256.keyMaterial;
};
export const topicDataToConversationReference = ({ invitation, createdNs, peerAddress, }) => ({
    context: invitation.context,
    topic: invitation.topic,
    peerAddress,
    createdNs,
});
export const isCompleteTopicData = (obj) => !!obj.invitation;
export const typeSafeTopicMap = (topicMap) => {
    const out = {};
    for (const [topic, topicData] of Object.entries(topicMap.topics)) {
        if (isCompleteTopicData(topicData)) {
            out[topic] = topicData;
        }
        else {
            // This should only happen if bad data somehow snuck through validation
            console.warn('Invitation missing from topic data');
        }
    }
    return out;
};
//# sourceMappingURL=utils.js.map