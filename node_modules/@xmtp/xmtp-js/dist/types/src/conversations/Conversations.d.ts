import { InvitationContext } from './../Invitation';
import { Conversation, ConversationV2 } from './Conversation';
import { DecodedMessage } from '../Message';
import Stream from '../Stream';
import Client from '../Client';
declare type CacheLoader = (args: {
    latestSeen: Date | undefined;
    existing: Conversation[];
}) => Promise<Conversation[]>;
export declare class ConversationCache {
    private conversations;
    private mutex;
    private latestSeen?;
    private seenTopics;
    constructor();
    load(loader: CacheLoader): Promise<Conversation[]>;
}
/**
 * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet
 */
export default class Conversations {
    private client;
    private v1Cache;
    private v2Mutex;
    constructor(client: Client);
    /**
     * List all conversations with the current wallet found in the network.
     */
    list(): Promise<Conversation[]>;
    private listV1Conversations;
    /**
     * List all V2 conversations
     */
    private listV2Conversations;
    private getV2ConversationsFromKeystore;
    updateV2Conversations(startTime?: Date): Promise<ConversationV2[]>;
    private decodeInvites;
    private saveInviteResponseToConversation;
    private conversationReferenceToV2;
    /**
     * Returns a stream of any newly created conversations.
     * Will dedupe to not return the same conversation twice in the same stream.
     * Does not dedupe any other previously seen conversations
     */
    stream(): Promise<Stream<Conversation>>;
    /**
     * Streams messages from all conversations.
     *
     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
     *
     */
    streamAllMessages(): Promise<AsyncGenerator<DecodedMessage>>;
    private getIntroductionPeers;
    /**
     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
     */
    newConversation(peerAddress: string, context?: InvitationContext): Promise<Conversation>;
    private createV2Convo;
    private getPeerAddress;
}
export {};
