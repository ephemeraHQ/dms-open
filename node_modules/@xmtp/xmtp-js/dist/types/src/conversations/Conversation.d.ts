import Stream from '../Stream';
import Client, { ListMessagesOptions, ListMessagesPaginatedOptions, SendOptions } from '../Client';
import { InvitationContext } from '../Invitation';
import { DecodedMessage, MessageV1, MessageV2 } from '../Message';
import { messageApi } from '@xmtp/proto';
import { PublicKeyBundle } from '../crypto';
/**
 * Conversation represents either a V1 or V2 conversation with a common set of methods.
 */
export interface Conversation {
    /**
     * A unique identifier for a conversation. Each conversation is stored on the network on one topic
     */
    topic: string;
    /**
     * The wallet address of the other party in the conversation
     */
    peerAddress: string;
    /**
     * Timestamp the conversation was created at
     */
    createdAt: Date;
    /**
     * Optional field containing the `conversationId` and `metadata` for V2 conversations.
     * Will always be undefined on V1 conversations
     */
    context?: InvitationContext | undefined;
    /**
     * Retrieve messages in this conversation. Default to returning all messages.
     *
     * If only a subset is required, results can be narrowed by specifying a start/end
     * timestamp.
     *
     * ```ts
     * // Get all messages in the past 24 hours
     * const messages = await conversation.messages({
     *    startTime: new Date(+new Date() - 86_400)
     * })
     * ```
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    /**
     * @deprecated
     */
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    /**
     * Takes a XMTP envelope as input and will decrypt and decode it
     * returning a `DecodedMessage` instance.
     */
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
    /**
     * Return a `Stream` of new messages in this conversation.
     *
     * Stream instances are async generators and can be used in
     * `for await` statements.
     *
     * ```ts
     * for await (const message of await conversation.stream()) {
     *    console.log(message.content)
     * }
     * ```
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    /**
     * Send a message into the conversation
     *
     * ## Example
     * ```ts
     * await conversation.send('Hello world') // returns a `DecodedMessage` instance
     * ```
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
}
/**
 * ConversationV1 allows you to view, stream, and send messages to/from a peer address
 */
export declare class ConversationV1 implements Conversation {
    peerAddress: string;
    createdAt: Date;
    context: undefined;
    private client;
    constructor(client: Client, address: string, createdAt: Date);
    get clientAddress(): string;
    get topic(): string;
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    processEnvelope({ message, contentTopic, }: messageApi.Envelope): Promise<MessageV1>;
    /**
     * Send a message into the conversation.
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
    decryptBatch(messages: MessageV1[], topic: string, throwOnError?: boolean): Promise<DecodedMessage[]>;
    private buildDecodedMessage;
    createMessage(payload: Uint8Array, recipient: PublicKeyBundle, timestamp?: Date): Promise<MessageV1>;
}
/**
 * ConversationV2
 */
export declare class ConversationV2 implements Conversation {
    client: Client;
    topic: string;
    peerAddress: string;
    createdAt: Date;
    context?: InvitationContext;
    constructor(client: Client, topic: string, peerAddress: string, createdAt: Date, context: InvitationContext | undefined);
    get clientAddress(): string;
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    /**
     * Send a message into the conversation
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
    createMessage(payload: Uint8Array, timestamp?: Date): Promise<MessageV2>;
    private decryptBatch;
    private buildDecryptRequest;
    private encryptMessage;
    private buildDecodedMessage;
    processEnvelope(env: messageApi.Envelope): Promise<MessageV2>;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
}
