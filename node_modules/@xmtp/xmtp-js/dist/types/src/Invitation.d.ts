import Long from 'long';
import { SignedPublicKeyBundle, SignedPublicKeyBundleV2 } from './crypto/PublicKeyBundle';
import { messageApi, invitation } from '@xmtp/proto';
import Ciphertext from './crypto/Ciphertext';
import { PrivateKeyBundleV2, PrivateKeyBundleV3 } from './crypto/PrivateKeyBundle';
export declare type InvitationContext = {
    conversationId: string;
    metadata: {
        [k: string]: string;
    };
};
/**
 * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message
 */
export declare class InvitationV1 implements invitation.InvitationV1 {
    topic: string;
    context: InvitationContext | undefined;
    aes256GcmHkdfSha256: invitation.InvitationV1_Aes256gcmHkdfsha256;
    constructor({ topic, context, aes256GcmHkdfSha256, }: invitation.InvitationV1);
    static createRandom(context?: invitation.InvitationV1_Context): InvitationV1;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): InvitationV1;
}
export declare class SealedInvitationHeaderV2 implements invitation.SealedInvitationHeaderV2 {
    peerHeader: invitation.SealedInvitationHeaderV2_PeerInvitationHeader | undefined;
    selfHeader: invitation.SealedInvitationHeaderV2_SelfInvitationHeader | undefined;
    private _sendKeyBundle;
    private _inboxKeyBundle;
    private _createdNs;
    constructor({ peerHeader, selfHeader }: invitation.SealedInvitationHeaderV2);
    static create(sendKeyBundle: PrivateKeyBundleV3, inboxKeyBundle: SignedPublicKeyBundleV2, peerAddress: string, created: Date): SealedInvitationHeaderV2;
    get createdNs(): Long;
    get sendKeyBundle(): SignedPublicKeyBundleV2;
    get inboxKeyBundle(): SignedPublicKeyBundleV2;
    getPeerAddress(selfAddress: string): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationHeaderV2;
}
export declare class SealedInvitationV2 implements invitation.SealedInvitationV2 {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    private _header?;
    private _invitation?;
    constructor({ headerBytes, ciphertext }: invitation.SealedInvitationV2);
    /**
     * Accessor method for the full header object
     */
    get header(): SealedInvitationHeaderV2;
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewerInboxKeyBundle: PrivateKeyBundleV3): Promise<InvitationV1>;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationV2;
}
/**
 * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1
 */
export declare class SealedInvitationHeaderV1 implements invitation.SealedInvitationHeaderV1 {
    sender: SignedPublicKeyBundle;
    recipient: SignedPublicKeyBundle;
    createdNs: Long;
    constructor({ sender, recipient, createdNs, }: invitation.SealedInvitationHeaderV1);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationHeaderV1;
}
export declare class SealedInvitationV1 implements invitation.SealedInvitationV1 {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    private _header?;
    private _invitation?;
    constructor({ headerBytes, ciphertext }: invitation.SealedInvitationV1);
    /**
     * Accessor method for the full header object
     */
    get header(): SealedInvitationHeaderV1;
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewer: PrivateKeyBundleV2): Promise<InvitationV1>;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationV1;
}
/**
 * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation
 */
export declare class SealedInvitation implements invitation.SealedInvitation {
    v1: SealedInvitationV1 | undefined;
    v2: SealedInvitationV2 | undefined;
    constructor({ v1, v2 }: invitation.SealedInvitation);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitation;
    static fromEnvelope(env: messageApi.Envelope): Promise<SealedInvitation>;
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     */
    static createV1({ sender, recipient, created, invitation, }: {
        sender: PrivateKeyBundleV2;
        recipient: SignedPublicKeyBundle;
        created: Date;
        invitation: InvitationV1;
    }): Promise<SealedInvitation>;
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     *
     * @param sendKeyBundle MUST be a bundle linked to the current viewer
     * @param inboxKeyBundle a bundle either linked to the current viewer, or to the invitee
     * @param peerAddress the address of the invitee to whom the invitation is being sent
     * @param created the time at which the invitation was created
     * @param invitation the invitation to be sent
     */
    static createV2({ sendKeyBundle, inboxKeyBundle, peerAddress, created, invitation, }: {
        sendKeyBundle: PrivateKeyBundleV3;
        inboxKeyBundle: SignedPublicKeyBundleV2;
        peerAddress: string;
        created: Date;
        invitation: InvitationV1;
    }): Promise<SealedInvitation>;
}
