import { PublicKeyBundle, SignedPublicKeyBundle } from './crypto';
import { EnvelopeMapper } from './utils';
import { Signer } from './types/Signer';
import { Conversations } from './conversations';
import { ContentTypeId, ContentCodec } from './MessageContent';
import { content as proto, messageApi } from '@xmtp/proto';
import ApiClient, { ApiUrls, PublishParams } from './ApiClient';
import { Flatten } from './utils/typedefs';
import BackupClient, { BackupType } from './message-backup/BackupClient';
import { Keystore } from './keystore';
import { KeystoreProvider } from './keystore/providers';
declare const Compression: typeof proto.Compression;
export declare type ListMessagesOptions = {
    checkAddresses?: boolean;
    startTime?: Date;
    endTime?: Date;
    limit?: number;
    direction?: messageApi.SortDirection;
};
export declare type ListMessagesPaginatedOptions = {
    startTime?: Date;
    endTime?: Date;
    pageSize?: number;
    direction?: messageApi.SortDirection;
};
export { Compression };
export declare type SendOptions = {
    contentType?: ContentTypeId;
    contentFallback?: string;
    compression?: proto.Compression;
    timestamp?: Date;
};
export declare type XmtpEnv = keyof typeof ApiUrls;
/**
 * Network startup options
 */
export declare type NetworkOptions = {
    /**
     * Specify which XMTP environment to connect to. (default: `dev`)
     */
    env: XmtpEnv;
    /**
     * apiUrl can be used to override the `env` flag and connect to a
     * specific endpoint
     */
    apiUrl: string | undefined;
    /**
     * identifier that's included with API requests.
     *
     * For example, you can use the following format:
     * `appVersion: APP_NAME + '/' + APP_VERSION`.
     * Setting this value provides telemetry that shows which apps are
     * using the XMTP client SDK. This information can help XMTP developers
     * provide app support, especially around communicating important
     * SDK updates, including deprecations and required upgrades.
     */
    appVersion?: string;
    /**
     * Skip publishing the user's contact bundle as part of Client startup.
     *
     * This flag should be used with caution, as we rely on contact publishing to
     * let other users know your public key and periodically run migrations on
     * this data with new SDK versions.
     *
     * Your application should have this flag set to `false` at least _some_ of the
     * time.
     *
     * The most common use-case for setting this to `true` is cases where the Client
     * instance is very short-lived. For example, spinning up a Client to decrypt
     * a push notification.
     */
    skipContactPublishing: boolean;
};
export declare type ContentOptions = {
    /**
     * Allow configuring codecs for additional content types
     */
    codecs: ContentCodec<any>[];
    /**
     * Set the maximum content size in bytes that is allowed by the Client.
     * Currently only checked when decompressing compressed content.
     */
    maxContentSize: number;
};
export declare type KeyStoreOptions = {
    /**
     * Provide an array of KeystoreProviders.
     * The client will attempt to use each one in sequence until one successfully
     * returns a Keystore instance
     */
    keystoreProviders: KeystoreProvider[];
    /**
     * Enable the Keystore to persist conversations in the provided storage interface
     */
    persistConversations: boolean;
    /**
     * Provide a XMTP PrivateKeyBundle encoded as a Uint8Array.
     * A bundle can be retried using `Client.getKeys(...)`
     */
    privateKeyOverride?: Uint8Array;
};
export declare type LegacyOptions = {
    publishLegacyContact?: boolean;
};
/**
 * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed
 * as needed by each function. All other defaults are specified in defaultOptions.
 */
export declare type ClientOptions = Flatten<NetworkOptions & KeyStoreOptions & ContentOptions & LegacyOptions>;
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
export declare function defaultOptions(opts?: Partial<ClientOptions>): ClientOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
export default class Client {
    address: string;
    keystore: Keystore;
    apiClient: ApiClient;
    contacts: Set<string>;
    publicKeyBundle: PublicKeyBundle;
    private knownPublicKeyBundles;
    private _backupClient;
    private _conversations;
    private _codecs;
    private _maxContentSize;
    constructor(publicKeyBundle: PublicKeyBundle, apiClient: ApiClient, backupClient: BackupClient, keystore: Keystore);
    /**
     * @type {Conversations}
     */
    get conversations(): Conversations;
    get backupType(): BackupType;
    get signedPublicKeyBundle(): SignedPublicKeyBundle;
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Client>;
    /**
     * Export the XMTP PrivateKeyBundle from the SDK as a `Uint8Array`.
     *
     * This bundle can then be provided as `privateKeyOverride` in a
     * subsequent call to `Client.create(...)`
     *
     * Be very careful with these keys, as they can be used to
     * impersonate a user on the XMTP network and read the user's
     * messages.
     */
    static getKeys(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Uint8Array>;
    private static setupBackupClient;
    private init;
    close(): Promise<void>;
    private ensureUserContactPublished;
    publishUserContact(legacy?: boolean): Promise<void>;
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     *
     * This throws if either the address is invalid or the contact is not published.
     * See also [#canMessage].
     */
    getUserContact(peerAddress: string): Promise<PublicKeyBundle | SignedPublicKeyBundle | undefined>;
    /**
     * Identical to getUserContact but for multiple peer addresses
     */
    getUserContacts(peerAddresses: string[]): Promise<(PublicKeyBundle | SignedPublicKeyBundle | undefined)[]>;
    /**
     * Used to force getUserContact fetch contact from the network.
     */
    forgetContact(peerAddress: string): void;
    canMessage(peerAddress: string): Promise<boolean>;
    canMessage(peerAddress: string[]): Promise<boolean[]>;
    static canMessage(peerAddress: string, opts?: Partial<NetworkOptions>): Promise<boolean>;
    static canMessage(peerAddress: string[], opts?: Partial<NetworkOptions>): Promise<boolean[]>;
    private validateEnvelope;
    /**
     * Low level method for publishing envelopes to the XMTP network with
     * no pre-processing or encryption applied.
     *
     * Primarily used internally
     *
     * @param envelopes PublishParams[]
     */
    publishEnvelopes(envelopes: PublishParams[]): Promise<void>;
    /**
     * Register a codec to be automatically used for encoding/decoding
     * messages of the given Content Type
     */
    registerCodec(codec: ContentCodec<any>): void;
    /**
     * Find a matching codec for a given `ContentTypeId` from the
     * client's codec registry
     */
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    /**
     * Convert arbitrary content into a serialized `EncodedContent` instance
     * with the given options
     */
    encodeContent(content: any, options?: SendOptions): Promise<Uint8Array>;
    listInvitations(opts?: ListMessagesOptions): Promise<messageApi.Envelope[]>;
    /**
     * List stored messages from the specified topic.
     *
     * A specified mapper function will be applied to each envelope.
     * If the mapper function throws an error during processing, the
     * envelope will be discarded.
     */
    listEnvelopes<Out>(topic: string, mapper: EnvelopeMapper<Out>, opts?: ListMessagesOptions): Promise<Out[]>;
    /**
     * List messages on a given set of content topics, yielding one page at a time
     */
    listEnvelopesPaginated<Out>(contentTopic: string, mapper: EnvelopeMapper<Out>, opts?: ListMessagesPaginatedOptions): AsyncGenerator<Out[]>;
}
/**
 * Get the default list of `KeystoreProviders` used in the SDK
 *
 * Particularly useful if a developer wants to add their own
 * provider to the head of the list while falling back to the
 * default functionality
 */
export declare function defaultKeystoreProviders(): KeystoreProvider[];
