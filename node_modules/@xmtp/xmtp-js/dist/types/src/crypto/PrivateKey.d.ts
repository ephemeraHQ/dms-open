import { privateKey } from '@xmtp/proto';
import Long from 'long';
import Signature, { AccountLinkedRole, AccountLinkSigner, ECDSACompactWithRecovery, KeySigner } from './Signature';
import { AccountLinkedPublicKey, PublicKey, SignedPublicKey, UnsignedPublicKey } from './PublicKey';
import Ciphertext from './Ciphertext';
declare type secp256k1 = {
    bytes: Uint8Array;
};
export declare class SignedPrivateKey implements privateKey.SignedPrivateKey, KeySigner {
    createdNs: Long;
    secp256k1: secp256k1;
    publicKey: SignedPublicKey;
    constructor(obj: privateKey.SignedPrivateKey);
    static generate(signer: KeySigner): Promise<SignedPrivateKey>;
    generated(): Date | undefined;
    sign(digest: Uint8Array): Promise<Signature>;
    signKey(pub: UnsignedPublicKey): Promise<SignedPublicKey>;
    static signerKey(key: SignedPublicKey, signature: ECDSACompactWithRecovery): Promise<UnsignedPublicKey | undefined>;
    sharedSecret(peer: SignedPublicKey | UnsignedPublicKey): Uint8Array;
    encrypt(plain: Uint8Array, peer: UnsignedPublicKey, additionalData?: Uint8Array): Promise<Ciphertext>;
    decrypt(encrypted: Ciphertext, peer: UnsignedPublicKey, additionalData?: Uint8Array): Promise<Uint8Array>;
    matches(key: SignedPublicKey): boolean;
    equals(other: this): boolean;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SignedPrivateKey;
    static fromLegacyKey(key: PrivateKey, signedByWallet?: boolean): SignedPrivateKey;
}
export declare class AccountLinkedPrivateKeyV1 implements privateKey.AccountLinkedPrivateKey_V1, KeySigner {
    createdNs: Long;
    secp256k1: secp256k1;
    publicKey: AccountLinkedPublicKey;
    constructor(obj: privateKey.AccountLinkedPrivateKey_V1);
    private sign;
    signKey(pub: UnsignedPublicKey): Promise<SignedPublicKey>;
    matches(key: AccountLinkedPublicKey): boolean;
}
export declare class AccountLinkedPrivateKey extends AccountLinkedPrivateKeyV1 implements privateKey.AccountLinkedPrivateKey {
    v1: privateKey.AccountLinkedPrivateKey_V1 | undefined;
    constructor(obj: privateKey.AccountLinkedPrivateKey);
    static generate(signer: AccountLinkSigner, role: AccountLinkedRole): Promise<AccountLinkedPrivateKey>;
    static fromLegacyKey(key: SignedPrivateKey, role: AccountLinkedRole): AccountLinkedPrivateKey;
    sharedSecret(peer: PublicKey | SignedPublicKey): Uint8Array;
}
export declare class PrivateKey implements privateKey.PrivateKey {
    timestamp: Long;
    secp256k1: secp256k1;
    publicKey: PublicKey;
    constructor(obj: privateKey.PrivateKey);
    static generate(): PrivateKey;
    generated(): Date | undefined;
    sign(digest: Uint8Array): Promise<Signature>;
    signKey(pub: PublicKey): Promise<PublicKey>;
    sharedSecret(peer: PublicKey | SignedPublicKey): Uint8Array;
    encrypt(plain: Uint8Array, peer: PublicKey, additionalData?: Uint8Array): Promise<Ciphertext>;
    decrypt(encrypted: Ciphertext, peer: PublicKey, additionalData?: Uint8Array): Promise<Uint8Array>;
    matches(key: PublicKey): boolean;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PrivateKey;
}
export {};
